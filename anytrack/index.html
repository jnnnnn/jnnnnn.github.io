<!DOCTYPE html>
<html lang="en">
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Activity Tracker</title>
        <script src="https://unpkg.com/d3@7"></script>
        <style>
            :root {
                --bg: #f7f7f7;
                --card: #fff;
                --muted: #e0e0e0;
                --primary: #4c84ff;
                --text: #000;
                --text-muted: #666;
                --border: #ddd;
                --shadow: rgba(0, 0, 0, 0.06);
            }

            body {
                font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
                margin: 0;
                background: var(--bg);
                color: var(--text);
            }

            h2 { margin: 0; font-size: 18px; }

            .container {
                display: flex;
                flex-direction: column;
                height: 100vh;
                padding: 14px;
                box-sizing: border-box;
                gap: 10px;
            }

            .card, #daily-report {
                background: var(--card);
                padding: 10px;
                border-radius: 12px;
                box-shadow: 0 1px 4px var(--shadow);
            }

            #daily-report { padding: 12px; }

            .row { display: flex; gap: 8px; }

            .action {
                flex: 1;
                padding: 14px;
                border-radius: 10px;
                border: 0;
                background: var(--muted);
                color: var(--text);
                font-size: 15px;
                cursor: pointer;
                transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
            }

            .action.fading {
                transform: scale(0.85);
                background: var(--primary);
                color: #fff;
                box-shadow: 0 4px 12px rgba(107, 159, 255, 0.4);
            }

            .btn {
                padding: 12px;
                border-radius: 10px;
                border: 0;
                cursor: pointer;
                font-size: 15px;
            }

            #undo-btn, #redo-btn { background: var(--primary); color: #fff; }
            #undo-btn:disabled, #redo-btn:disabled { background: var(--muted); color: var(--text-muted); cursor: not-allowed; }
            #download { background: #4caf50; color: #fff; }

            input[type="text"], #date-selector input[type="date"] {
                padding: 12px;
                border-radius: 8px;
                border: 1px solid var(--border);
                background: var(--card);
                color: var(--text);
                box-sizing: border-box;
            }

            input[type="text"] { width: 100%; font-size: 15px; }

            small.timestamp {
                display: block;
                margin-top: 6px;
                color: var(--text-muted);
                font-size: 12px;
            }

            #daily-report h3 {
                margin: 0 0 12px 0;
                font-size: 16px;
                display: flex;
                justify-content: space-between;
                align-items: center;
            }

            #date-selector {
                display: flex;
                gap: 8px;
                align-items: center;
                margin-bottom: 12px;
            }

            #date-selector input[type="date"] { flex: 1; padding: 8px; border-radius: 6px; font-size: 14px; }
            #date-selector button { padding: 8px 12px; border-radius: 6px; border: 0; background: var(--muted); color: var(--text); cursor: pointer; font-size: 14px; }

            .stats-grid {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
                gap: 10px;
                margin-bottom: 16px;
            }

            .stat-card { background: var(--bg); padding: 10px; border-radius: 8px; text-align: center; }
            .stat-card .label { font-size: 12px; color: var(--text-muted); margin-bottom: 4px; }
            .stat-card .value { font-size: 20px; font-weight: 600; color: var(--text); }

            .hourly-grid {
                display: grid;
                grid-template-columns: auto repeat(24, 1fr);
                gap: 2px;
                margin-bottom: 16px;
                align-items: center;
            }

            .hour-col { display: flex; flex-direction: column; gap: 2px; }

            .row-label, .hour-label { color: var(--text-muted); }
            .row-label { font-size: 11px; padding: 4px 8px 4px 0; text-align: right; white-space: nowrap; }
            .hour-label { font-size: 10px; text-align: center; margin-bottom: 2px; }

            .hour-indicator {
                width: 100%;
                height: 20px;
                border-radius: 3px;
                background: var(--muted);
                position: relative;
            }

            .hour-indicator.feed { background: #4caf50; }
            .hour-indicator.sleep { background: #2196f3; }
            .hour-indicator.nap { background: #64b5f6; }
            .hour-indicator.wet { background: #ff9800; }
            .hour-indicator.dirty { background: #795548; }
            .hour-indicator.soothe { background: #9c27b0; }

            .sleep-attempts { margin-top: 12px; }
            .sleep-attempts h4, .recent-events h4 { font-size: 14px; margin: 0 0 8px 0; color: var(--text-muted); }

            .attempt-list, .event-list { display: flex; flex-direction: column; gap: 4px; }

            .attempt, .event-entry {
                padding: 6px 10px;
                background: var(--bg);
                border-radius: 6px;
                font-size: 13px;
                display: flex;
                justify-content: space-between;
                transition: all 0.2s ease;
            }

            .event-entry { padding: 8px 10px; align-items: center; }

            .attempt.success { background: #e8f5e9; color: #2e7d32; }
            .attempt.fail { background: #ffebee; color: #c62828; }

            #timeline-chart { margin-top: 16px; border-top: 1px solid var(--muted); padding-top: 16px; }
            .recent-events { margin-top: 12px; }

            .event-type { font-weight: 600; color: var(--primary); text-transform: capitalize; }
            .event-value { color: var(--text); margin-left: 4px; }
            .event-time { color: var(--text-muted); font-size: 12px; }

            .modal-overlay {
                display: none;
                position: fixed;
                top: 0; left: 0; right: 0; bottom: 0;
                background: rgba(0, 0, 0, 0.5);
                z-index: 1000;
                align-items: center;
                justify-content: center;
            }

            .modal-overlay.show { display: flex; }

            .modal {
                background: var(--card);
                padding: 20px;
                border-radius: 12px;
                box-shadow: 0 4px 12px var(--shadow);
                max-width: 90%;
                width: 300px;
            }

            .modal h3 { margin: 0 0 16px 0; font-size: 16px; }

            .modal input[type="datetime-local"] {
                width: 100%;
                padding: 10px;
                border-radius: 8px;
                border: 1px solid var(--border);
                background: var(--bg);
                color: var(--text);
                font-size: 15px;
                box-sizing: border-box;
                margin-bottom: 16px;
            }

            .modal-buttons { display: flex; gap: 8px; }
            .modal-buttons button { flex: 1; padding: 10px; border-radius: 8px; border: 0; cursor: pointer; font-size: 14px; }
            .modal-buttons .cancel { background: var(--muted); }
            .modal-buttons .confirm { background: var(--primary); color: #fff; }

            .config-editor { max-width: 600px; width: 95%; max-height: 80vh; overflow-y: auto; }
            .config-editor textarea { width: 100%; min-height: 400px; font-family: monospace; font-size: 12px; padding: 10px; border-radius: 8px; border: 1px solid var(--border); background: var(--bg); color: var(--text); box-sizing: border-box; resize: vertical; }
            .config-templates { display: flex; gap: 8px; margin-bottom: 12px; flex-wrap: wrap; }
            .config-templates button { padding: 8px 12px; border-radius: 6px; border: 0; background: var(--muted); color: var(--text); cursor: pointer; font-size: 13px; }
            .config-templates button:hover { background: var(--primary); color: #fff; }
            .config-error { color: #f44336; font-size: 13px; margin-top: 8px; display: none; }

            #settings-btn { position: fixed; top: 14px; right: 14px; padding: 10px; border-radius: 50%; border: 0; background: var(--muted); color: var(--text); cursor: pointer; font-size: 18px; width: 40px; height: 40px; display: flex; align-items: center; justify-content: center; box-shadow: 0 2px 8px var(--shadow); z-index: 100; }
            #settings-btn:hover { background: var(--primary); color: #fff; }

            .event-tooltip { font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; line-height: 1.4; }
            .event-tooltip strong { color: var(--primary); }

            #event-filter:focus, #event-type-filter:focus {
                outline: none;
                border-color: var(--primary);
                box-shadow: 0 0 0 2px rgba(107, 159, 255, 0.3);
            }

            .event-entry.deleted { opacity: 0.5; background: var(--muted) !important; color: var(--text-muted) !important; filter: grayscale(1); }

            .action-btn {
                border: none;
                border-radius: 3px;
                padding: 2px 6px;
                font-size: 10px;
                margin-left: 8px;
                cursor: pointer;
                opacity: 0.7;
                transition: opacity 0.2s ease;
            }

            .action-btn:hover { opacity: 1; }
            .delete-btn { background: var(--muted); color: var(--text-muted); }
            .undelete-btn { background: #e8f5e9; color: #4caf50; }

            .tab-container { margin-top: 12px; }
            .tab-buttons { display: flex; gap: 4px; margin-bottom: 12px; border-bottom: 2px solid var(--muted); }

            .tab-btn {
                padding: 10px 16px;
                background: none;
                border: none;
                cursor: pointer;
                font-size: 15px;
                color: var(--text-muted);
                border-bottom: 3px solid transparent;
                margin-bottom: -2px;
                transition: all 0.2s ease;
            }

            .tab-btn:hover { color: var(--primary); }
            .tab-btn.active { color: var(--primary); border-bottom-color: var(--primary); font-weight: 600; }

            .tabs-wrapper { display: flex; flex-direction: column; gap: 12px; }
            .tab-content { display: none; }
            .tab-content.active { display: block; }

            @media (prefers-color-scheme: dark) {
                :root {
                    --bg: #1a1a1a;
                    --card: #2d2d2d;
                    --muted: #404040;
                    --primary: #4e72b5;
                    --text: #e0e0e0;
                    --text-muted: #999;
                    --border: #555;
                    --shadow: rgba(0, 0, 0, 0.3);
                }
                .action.fading { box-shadow: 0 4px 12px rgba(107, 159, 255, 0.6); }
                #download { background: #366438; }
                .hour-indicator.feed { background: #66bb6a; }
                .hour-indicator.sleep { background: #42a5f5; }
                .hour-indicator.nap { background: #90caf9; }
                .hour-indicator.wet { background: #ffa726; }
                .hour-indicator.dirty { background: #8d6e63; }
                .hour-indicator.soothe { background: #ab47bc; }
                .attempt.success { background: #1b5e20; color: #a5d6a7; }
                .attempt.fail { background: #b71c1c; color: #ef9a9a; }
                .undelete-btn { background: #1b5e20; color: #81c784; }
            }

            @media (min-width: 1200px) {
                .tab-buttons { display: none; }
                .tabs-wrapper { display: grid; grid-template-columns: 30em 1fr; gap: 16px; }
                .tab-content { display: block; }
                #log-tab { order: 1; }
                #graphs-tab { order: 2; }
            }
        </style>
        <script>
            let db = null;

            // Tab switching
            function switchTab(tabName) {
                // Hide all tab contents
                document.querySelectorAll(".tab-content").forEach((tab) => {
                    tab.classList.remove("active");
                });
                // Deactivate all tab buttons
                document.querySelectorAll(".tab-btn").forEach((btn) => {
                    btn.classList.remove("active");
                });
                // Show selected tab content
                document
                    .getElementById(tabName + "-tab")
                    .classList.add("active");
                // Activate selected tab button
                document
                    .querySelector(`[data-tab="${tabName}"]`)
                    .classList.add("active");
            }

            // Initialize IndexedDB
            async function initDB() {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open("ActivityTrackerDB", 1);

                    request.onerror = () => reject(request.error);
                    request.onsuccess = () => {
                        db = request.result;
                        resolve(db);
                    };

                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        const oldVersion = event.oldVersion;

                        if (oldVersion < 1) {
                            // Create initial schema with deleted column included
                            const objectStore = db.createObjectStore(
                                "entries",
                                { keyPath: "id", autoIncrement: true }
                            );
                            objectStore.createIndex("timestamp", "ts", {
                                unique: false,
                            });
                            // Note: deleted field will be added when creating entries
                        }
                    };
                });
            }

            // Add a single entry to the database
            async function addEntry(type, value, ts) {
                if (!db) await initDB();

                const transaction = db.transaction(["entries"], "readwrite");
                const objectStore = transaction.objectStore("entries");
                const entry = { type, value, ts, deleted: false };
                objectStore.add(entry);

                return new Promise((resolve, reject) => {
                    transaction.oncomplete = resolve;
                    transaction.onerror = () => reject(transaction.error);
                });
            }

            async function loadEntriesByDate(date) {
                if (!db) await initDB();

                const transaction = db.transaction(["entries"], "readonly");
                const objectStore = transaction.objectStore("entries");

                let range;
                if (date) {
                    const { start, end } = getDayBounds(date);
                    // Query 12 hours before and after to catch sleep periods that cross midnight
                    const expandedStart = new Date(
                        new Date(start).getTime() - 12 * 60 * 60 * 1000
                    ).toISOString();
                    const expandedEnd = new Date(
                        new Date(end).getTime() + 12 * 60 * 60 * 1000
                    ).toISOString();
                    range = IDBKeyRange.bound(expandedStart, expandedEnd);
                } else {
                    const yesterday = new Date(
                        Date.now() - 36 * 60 * 60 * 1000
                    ).toISOString();
                    range = IDBKeyRange.lowerBound(yesterday);
                }

                const request = objectStore.index("timestamp").getAll(range);

                return new Promise((resolve, reject) => {
                    request.onsuccess = () => resolve(request.result || []);
                    request.onerror = () => reject(request.error);
                });
            }

            async function clearAllEntries() {
                if (!db) await initDB();

                const transaction = db.transaction(["entries"], "readwrite");
                const objectStore = transaction.objectStore("entries");
                objectStore.clear();

                return new Promise((resolve, reject) => {
                    transaction.oncomplete = resolve;
                    transaction.onerror = () => reject(transaction.error);
                });
            }

            function nowIso() {
                return new Date().toISOString();
            }

            // Helper to format elapsed time
            function formatElapsedTime(timestampMs) {
                const elapsed = Math.floor(
                    (Date.now() - timestampMs) / 1000 / 60
                );
                const hours = Math.floor(elapsed / 60);
                const mins = elapsed % 60;
                return hours > 0 ? `${hours}h ${mins}m ago` : `${mins}m ago`;
            }

            // Helper to create day boundary timestamps
            function getDayBounds(date) {
                // Create start/end in local timezone - these are Date objects representing
                // midnight and end-of-day in the local timezone
                const start = new Date(
                    date.getFullYear(),
                    date.getMonth(),
                    date.getDate(),
                    0,
                    0,
                    0,
                    0
                );
                const end = new Date(
                    date.getFullYear(),
                    date.getMonth(),
                    date.getDate(),
                    23,
                    59,
                    59,
                    999
                );
                // Return ISO strings for database queries - these will be in UTC but represent
                // the local day boundaries
                return { start: start.toISOString(), end: end.toISOString() };
            }

            // Helper to get day bounds as Date objects (not ISO strings)
            function getDayBoundsAsDate(date) {
                const { start, end } = getDayBounds(date);
                return { dayStart: new Date(start), dayEnd: new Date(end) };
            }

            // Helper to check if an entry is within day boundaries
            function isEntryInDay(entry, dayStart, dayEnd) {
                const ts = new Date(entry.ts);
                return ts >= dayStart && ts <= dayEnd;
            }

            // Helper to filter entries to only those within the day
            function filterEntriesInDay(entries, date) {
                const { dayStart, dayEnd } = getDayBoundsAsDate(date);
                return entries.filter((e) => isEntryInDay(e, dayStart, dayEnd));
            }

            // Helper to update button display with time and highlight
            function updateButtonDisplay(
                btn,
                label,
                timeStr = null,
                highlight = false
            ) {
                if (!btn) return;
                const opacity = highlight ? "0.9" : "0.8";
                btn.style.background = highlight ? "var(--primary)" : "";
                btn.style.color = highlight ? "#fff" : "";
                btn.innerHTML = timeStr
                    ? `${label}<br><small style="font-size: 11px; opacity: ${opacity};">${timeStr}</small>`
                    : label;
            }

            // Long-press detection
            let longPressTimer = null;
            let longPressData = null;

            function handleLongPressStart(type, value, btn, event) {
                event.preventDefault();
                longPressTimer = setTimeout(() => {
                    // Show time picker modal
                    longPressData = { type, value, btn };
                    showTimePicker();
                }, 500); // 500ms for long press
            }

            function handleLongPressEnd() {
                if (longPressTimer) {
                    clearTimeout(longPressTimer);
                    longPressTimer = null;
                }
            }

            function showTimePicker() {
                const modal = document.getElementById("time-picker-modal");
                const input = document.getElementById("custom-time");

                // Set default to current time in local timezone
                // datetime-local expects format: YYYY-MM-DDTHH:mm
                const now = new Date();
                const year = now.getFullYear();
                const month = String(now.getMonth() + 1).padStart(2, "0");
                const day = String(now.getDate()).padStart(2, "0");
                const hours = String(now.getHours()).padStart(2, "0");
                const minutes = String(now.getMinutes()).padStart(2, "0");
                input.value = `${year}-${month}-${day}T${hours}:${minutes}`;

                modal.classList.add("show");
            }

            function hideTimePicker() {
                const modal = document.getElementById("time-picker-modal");
                modal.classList.remove("show");
                longPressData = null;
            }

            // Helper to find last sleep start entry
            function findLastSleepStart(entries) {
                return [...entries]
                    .reverse()
                    .find(
                        (e) =>
                            !e.deleted &&
                            e.type === "sleep" &&
                            (e.value === "sleeping" || e.value === "nap")
                    );
            }

            async function save(type, value, btn, customTimestamp = null) {
                const ts = customTimestamp || nowIso();
                const eventTime = new Date(ts);

                // Add animation
                if (btn) {
                    btn.classList.add("fading");
                    setTimeout(() => {
                        btn.classList.remove("fading");
                    }, 400);
                }

                // Persist this single entry
                await addEntryWithUndo(type, value, ts);

                updateTimestamp("Saved: " + eventTime.toLocaleTimeString());
                updateDailyReport();
                updateButtonStates();
            }

            async function saveWithCustomTime() {
                const input = document.getElementById("custom-time");
                const customTime = new Date(input.value);

                if (!customTime || isNaN(customTime.getTime())) {
                    alert("Please select a valid time");
                    return;
                }

                const { type, value, btn } = longPressData;
                await save(type, value, btn, customTime.toISOString());
                hideTimePicker();
            }

            // Toggle entry deleted status
            async function toggleEntryDeleted(entryId, shouldDelete) {
                if (!db) await initDB();

                const transaction = db.transaction(["entries"], "readwrite");
                const objectStore = transaction.objectStore("entries");

                return new Promise((resolve, reject) => {
                    const getRequest = objectStore.get(entryId);
                    getRequest.onsuccess = () => {
                        const entry = getRequest.result;
                        if (entry && entry.deleted !== shouldDelete) {
                            entry.deleted = shouldDelete;
                            const updateRequest = objectStore.put(entry);
                            updateRequest.onsuccess = () => resolve(entry);
                            updateRequest.onerror = () =>
                                reject(updateRequest.error);
                        } else {
                            resolve(null);
                        }
                    };
                    getRequest.onerror = () => reject(getRequest.error);
                });
            }

            // Simple undo system with single stack
            let actionStack = [];
            let currentPosition = -1;
            const MAX_STACK_SIZE = 20;

            function addAction(action) {
                // Remove any actions after current position (for new actions after undo)
                actionStack = actionStack.slice(0, currentPosition + 1);
                actionStack.push(action);
                currentPosition = actionStack.length - 1;

                // Limit stack size
                if (actionStack.length > MAX_STACK_SIZE) {
                    actionStack.shift();
                    currentPosition--;
                }

                updateUndoRedoButtons();
            }

            function updateUndoRedoButtons() {
                const undoBtn = document.getElementById("undo-btn");
                const redoBtn = document.getElementById("redo-btn");

                if (undoBtn) {
                    // Undo is always available now
                    undoBtn.disabled = false;
                    undoBtn.textContent = "Undo";
                }
                if (redoBtn) {
                    redoBtn.disabled =
                        currentPosition >= actionStack.length - 1;
                    redoBtn.textContent =
                        currentPosition < actionStack.length - 1
                            ? "Redo"
                            : "Redo";
                }
            }

            // Simple entry functions
            async function deleteEntry(id) {
                const entry = await toggleEntryDeleted(id, true);
                if (entry) {
                    addAction({
                        type: "toggle",
                        entryId: id,
                        wasDeleted: false,
                    });
                }
                return entry;
            }

            async function undeleteEntry(id) {
                const entry = await toggleEntryDeleted(id, false);
                if (entry) {
                    addAction({
                        type: "toggle",
                        entryId: id,
                        wasDeleted: true,
                    });
                }
                return entry;
            }

            async function addEntryWithUndo(type, value, ts) {
                await addEntry(type, value, ts);
                const allEntries = await loadEntriesByDate();
                const newEntry = allEntries[allEntries.length - 1];
                if (newEntry) {
                    addAction({ type: "add", entryId: newEntry.id });
                }
            }

            async function undo() {
                if (
                    currentPosition >= 0 &&
                    currentPosition < actionStack.length
                ) {
                    // Normal undo operation when there are actions to undo
                    const action = actionStack[currentPosition];
                    currentPosition--;

                    if (action.type === "add") {
                        await toggleEntryDeleted(action.entryId, true);
                        updateTimestamp("Undid add");
                    } else if (action.type === "toggle") {
                        await toggleEntryDeleted(
                            action.entryId,
                            action.wasDeleted
                        );
                        updateTimestamp(
                            action.wasDeleted
                                ? "Undid undelete"
                                : "Undid delete"
                        );
                    }
                } else {
                    // Stack is empty or at the end - find most recent undeleted item and mark it as deleted
                    const allEntries = await loadEntriesByDate();
                    const activeEntries = allEntries.filter((e) => !e.deleted);

                    if (activeEntries.length > 0) {
                        // Find the most recent entry by timestamp
                        const mostRecentEntry = activeEntries.reduce(
                            (latest, entry) => {
                                return new Date(entry.ts) > new Date(latest.ts)
                                    ? entry
                                    : latest;
                            }
                        );

                        await toggleEntryDeleted(mostRecentEntry.id, true);
                        addAction({
                            type: "toggle",
                            entryId: mostRecentEntry.id,
                            wasDeleted: false,
                        });
                        // After adding the action, we're now at the end of the stack, so move currentPosition forward
                        currentPosition = actionStack.length;
                        updateTimestamp(
                            `Deleted most recent: ${mostRecentEntry.type} - ${mostRecentEntry.value}`
                        );
                    } else {
                        updateTimestamp("No entries to undo");
                        return;
                    }
                }

                updateDailyReport();
                updateButtonStates();
                updateUndoRedoButtons();
            }

            async function redo() {
                if (currentPosition >= actionStack.length - 1) return;

                currentPosition++;
                const action = actionStack[currentPosition];

                if (action.type === "add") {
                    await toggleEntryDeleted(action.entryId, false);
                    updateTimestamp("Redid add");
                } else if (action.type === "toggle") {
                    await toggleEntryDeleted(
                        action.entryId,
                        !action.wasDeleted
                    );
                    updateTimestamp(
                        action.wasDeleted ? "Redid undelete" : "Redid delete"
                    );
                }

                updateDailyReport();
                updateButtonStates();
                updateUndoRedoButtons();
            }

            function updateTimestamp(text) {
                const stamp = document.getElementById("laststamp");
                if (stamp) stamp.textContent = text;
            }

            async function saveNote(e) {
                const v = e.target.value.trim();
                if (!v) return;
                await save("note", v);
                e.target.value = "";
            }

            async function downloadCSV() {
                const entries = await loadEntriesByDate();

                if (!entries || entries.length === 0) {
                    alert("No data to export");
                    return;
                }

                // Filter deleted entries based on checkbox state
                const hideDeleted =
                    document.getElementById("hide-deleted-filter")?.checked ??
                    true;
                const exportEntries = hideDeleted
                    ? entries.filter((e) => !e.deleted)
                    : entries;

                if (exportEntries.length === 0) {
                    alert("No data to export (all entries are deleted)");
                    return;
                }

                const header = "Timestamp,Type,Value";
                const rows = exportEntries.map((e) => {
                    // Convert UTC timestamp to ISO format with local timezone offset
                    const date = new Date(e.ts);
                    const offset = -date.getTimezoneOffset();
                    const sign = offset >= 0 ? "+" : "-";
                    const hours = String(
                        Math.floor(Math.abs(offset) / 60)
                    ).padStart(2, "0");
                    const mins = String(Math.abs(offset) % 60).padStart(2, "0");

                    const year = date.getFullYear();
                    const month = String(date.getMonth() + 1).padStart(2, "0");
                    const day = String(date.getDate()).padStart(2, "0");
                    const hour = String(date.getHours()).padStart(2, "0");
                    const minute = String(date.getMinutes()).padStart(2, "0");
                    const second = String(date.getSeconds()).padStart(2, "0");

                    const localTime = `${year}-${month}-${day}T${hour}:${minute}:${second}${sign}${hours}:${mins}`;
                    return `"${localTime}","${e.type}","${e.value}"`;
                });
                const csv = [header, ...rows].join("\n");

                const blob = new Blob([csv], {
                    type: "text/csv;charset=utf-8;",
                });
                const url = URL.createObjectURL(blob);
                const a = document.createElement("a");
                a.href = url;
                a.download =
                    "activity_log_" +
                    new Date().toISOString().split("T")[0] +
                    ".csv";
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }

            async function updateButtonStates() {
                if (!db) await initDB();

                // Load today's entries
                const today = new Date();
                const { start, end } = getDayBounds(today);
                const transaction = db.transaction(["entries"], "readonly");
                const objectStore = transaction.objectStore("entries");
                const request = objectStore
                    .index("timestamp")
                    .getAll(IDBKeyRange.bound(start, end));

                const allEntries = await new Promise((resolve, reject) => {
                    request.onsuccess = () => resolve(request.result || []);
                    request.onerror = () => reject(request.error);
                });

                if (!allEntries || allEntries.length === 0) return;

                // Filter out deleted entries for button states
                const activeEntries = allEntries.filter((e) => !e.deleted);
                if (activeEntries.length === 0) return;

                // Update button states for each group in config
                currentConfig.groups.forEach((group) => {
                    // For counted buttons, show the last timestamp
                    group.buttons.forEach((btn) => {
                        if (btn.counted) {
                            const lastEvent = [...activeEntries]
                                .reverse()
                                .find((e) => e.type === btn.type && e.value === btn.value);
                            const button = document.querySelector(
                                `button[data-type="${btn.type}"][data-value="${btn.value}"]`
                            );
                            const eventTime = lastEvent
                                ? formatElapsedTime(new Date(lastEvent.ts).getTime())
                                : null;
                            updateButtonDisplay(button, btn.label, eventTime, false);
                        }
                    });

                    // For stateful groups, highlight the current state
                    if (group.stateful) {
                        const lastEvent = [...activeEntries]
                            .reverse()
                            .find((e) => group.buttons.some(btn => btn.type === e.type));

                        group.buttons.forEach((btn) => {
                            const button = document.querySelector(
                                `button[data-type="${btn.type}"][data-value="${btn.value}"]`
                            );
                            if (button) {
                                const isActive = lastEvent && lastEvent.value === btn.value;
                                const eventTime = (lastEvent && lastEvent.value === btn.value)
                                    ? formatElapsedTime(new Date(lastEvent.ts).getTime())
                                    : null;
                                updateButtonDisplay(button, btn.label, eventTime, isActive);
                            }
                        });
                    }
                });
            }

            document.addEventListener("keydown", (e) => {
                if (
                    e.key === "Enter" &&
                    document.activeElement?.id === "notes"
                ) {
                    saveNote({ target: document.activeElement });
                }
            });

            // Initialize database on load
            initDB();

            // Update button states every minute to keep elapsed times current
            setInterval(() => {
                updateButtonStates();
            }, 60000); // 60000ms = 1 minute

            // Daily Report Functions
            let currentReportDate = new Date();

            function setReportDate(date) {
                // Parse date string as local date, not UTC
                if (typeof date === "string") {
                    const parts = date.split("-");
                    currentReportDate = new Date(
                        parseInt(parts[0]),
                        parseInt(parts[1]) - 1,
                        parseInt(parts[2])
                    );
                } else {
                    currentReportDate = new Date(date);
                }
                updateDailyReport();
            }

            function changeReportDate(days) {
                currentReportDate.setDate(currentReportDate.getDate() + days);
                // Format date as YYYY-MM-DD for the date input
                const year = currentReportDate.getFullYear();
                const month = String(currentReportDate.getMonth() + 1).padStart(
                    2,
                    "0"
                );
                const day = String(currentReportDate.getDate()).padStart(
                    2,
                    "0"
                );
                document.getElementById(
                    "report-date"
                ).value = `${year}-${month}-${day}`;
                updateDailyReport();
            }

            function goToToday() {
                const today = new Date();
                const year = today.getFullYear();
                const month = String(today.getMonth() + 1).padStart(2, "0");
                const day = String(today.getDate()).padStart(2, "0");
                setReportDate(`${year}-${month}-${day}`);
            }

            // Default Configuration Templates
            const configTemplates = {
                baby: {
                    title: "Baby Daily Log",
                    groups: [
                        {
                            name: "Feed",
                            stateful: false,
                            counted: true,
                            buttons: [
                                { type: "feed", value: "bf", label: "Feed", emoji: "ðŸ¤±", counted: true },
                                { type: "feed", value: "play", label: "Play", emoji: "ðŸŽ¾" },
                                { type: "feed", value: "spew", label: "Spew", emoji: "ðŸ¤®" },
                            ],
                        },
                        {
                            name: "Sleep",
                            stateful: true,
                            counted: false,
                            buttons: [
                                { type: "sleep", value: "sleeping", label: "Sleeping", emoji: "" },
                                { type: "sleep", value: "nap", label: "Nap", emoji: "" },
                                { type: "sleep", value: "awake", label: "Awake", emoji: "" },
                                { type: "sleep", value: "grizzle", label: "Grizzle", emoji: "" },
                            ],
                        },
                        {
                            name: "Nappy",
                            stateful: false,
                            counted: true,
                            buttons: [
                                { type: "nappy", value: "wet", label: "Wet", emoji: "ðŸ’§", counted: true },
                                { type: "nappy", value: "dirty", label: "Dirty", emoji: "ðŸ’©", counted: true },
                            ],
                        },
                        {
                            name: "Soothe",
                            stateful: false,
                            counted: false,
                            buttons: [
                                { type: "soothe", value: "pram", label: "Pram", emoji: "ðŸŽ¢" },
                                { type: "soothe", value: "rocking", label: "Rocking", emoji: "ðŸª‘" },
                                { type: "soothe", value: "wearing", label: "Wearing", emoji: "ðŸ¤—" },
                                { type: "soothe", value: "feed-to-sleep", label: "Feed to Sleep", emoji: "ðŸ¼ðŸ˜´" },
                            ],
                        },
                        {
                            name: "5 S's",
                            stateful: false,
                            counted: false,
                            buttons: [
                                { type: "5s", value: "swaddle", label: "Swaddle", emoji: "ðŸŒ¯" },
                                { type: "5s", value: "side-lying", label: "Side/Stomach", emoji: "ðŸ›ï¸" },
                                { type: "5s", value: "shush", label: "Shush", emoji: "ðŸ¤«" },
                                { type: "5s", value: "swing", label: "Swing", emoji: "ðŸŽ¢" },
                                { type: "5s", value: "suck", label: "Suck", emoji: "ðŸ­" },
                            ],
                        },
                    ],
                },
                warehouse: {
                    title: "Warehouse Inventory",
                    groups: [
                        {
                            name: "Receiving",
                            stateful: false,
                            counted: true,
                            buttons: [
                                { type: "receiving", value: "pallet", label: "Pallet", emoji: "ðŸ“¦", counted: true },
                                { type: "receiving", value: "box", label: "Box", emoji: "ðŸ“¦", counted: true },
                                { type: "receiving", value: "damage", label: "Damage", emoji: "âš ï¸", counted: true },
                            ],
                        },
                        {
                            name: "Status",
                            stateful: true,
                            counted: false,
                            buttons: [
                                { type: "status", value: "open", label: "Open", emoji: "ðŸŸ¢" },
                                { type: "status", value: "lunch", label: "Lunch Break", emoji: "ðŸ½ï¸" },
                                { type: "status", value: "closed", label: "Closed", emoji: "ðŸ”´" },
                            ],
                        },
                        {
                            name: "Shipping",
                            stateful: false,
                            counted: true,
                            buttons: [
                                { type: "shipping", value: "standard", label: "Standard", emoji: "ðŸšš", counted: true },
                                { type: "shipping", value: "express", label: "Express", emoji: "âš¡", counted: true },
                                { type: "shipping", value: "pickup", label: "Pickup", emoji: "ðŸ¤", counted: true },
                            ],
                        },
                    ],
                },
                lab: {
                    title: "Lab Experiment Log",
                    groups: [
                        {
                            name: "Equipment",
                            stateful: true,
                            counted: false,
                            buttons: [
                                { type: "equipment", value: "on", label: "Equipment On", emoji: "ðŸ”›" },
                                { type: "equipment", value: "off", label: "Equipment Off", emoji: "â¹ï¸" },
                                { type: "equipment", value: "maintenance", label: "Maintenance", emoji: "ðŸ”§" },
                            ],
                        },
                        {
                            name: "Samples",
                            stateful: false,
                            counted: true,
                            buttons: [
                                { type: "sample", value: "collected", label: "Collected", emoji: "ðŸ§ª", counted: true },
                                { type: "sample", value: "processed", label: "Processed", emoji: "âš—ï¸", counted: true },
                                { type: "sample", value: "stored", label: "Stored", emoji: "â„ï¸", counted: true },
                            ],
                        },
                        {
                            name: "Observations",
                            stateful: false,
                            counted: false,
                            buttons: [
                                { type: "observation", value: "normal", label: "Normal", emoji: "âœ…" },
                                { type: "observation", value: "anomaly", label: "Anomaly", emoji: "âš ï¸" },
                                { type: "observation", value: "critical", label: "Critical", emoji: "ðŸš¨" },
                            ],
                        },
                    ],
                },
            };

            // Load or initialize configuration
            function loadConfig() {
                const saved = localStorage.getItem("trackerConfig");
                if (saved) {
                    try {
                        return JSON.parse(saved);
                    } catch (e) {
                        console.error("Failed to parse saved config:", e);
                    }
                }
                // Default to baby template
                return configTemplates.baby;
            }

            function saveConfig(config) {
                localStorage.setItem("trackerConfig", JSON.stringify(config));
            }

            let currentConfig = loadConfig();

            // Config Editor Functions
            function showConfigEditor() {
                const modal = document.getElementById("config-editor-modal");
                const textarea = document.getElementById("config-json");
                textarea.value = JSON.stringify(currentConfig, null, 2);
                document.getElementById("config-error").style.display = "none";
                modal.classList.add("show");
            }

            function hideConfigEditor() {
                const modal = document.getElementById("config-editor-modal");
                modal.classList.remove("show");
            }

            function loadTemplate(templateName) {
                const template = configTemplates[templateName];
                if (template) {
                    const textarea = document.getElementById("config-json");
                    textarea.value = JSON.stringify(template, null, 2);
                    document.getElementById("config-error").style.display = "none";
                }
            }

            function saveConfigFromEditor() {
                const textarea = document.getElementById("config-json");
                const errorDiv = document.getElementById("config-error");
                
                try {
                    const newConfig = JSON.parse(textarea.value);
                    
                    // Validate config structure
                    if (!newConfig.title || !Array.isArray(newConfig.groups)) {
                        throw new Error("Config must have 'title' and 'groups' array");
                    }
                    
                    newConfig.groups.forEach((group, i) => {
                        if (!group.name || !Array.isArray(group.buttons)) {
                            throw new Error(`Group ${i} must have 'name' and 'buttons' array`);
                        }
                        group.buttons.forEach((btn, j) => {
                            if (!btn.type || !btn.value || !btn.label) {
                                throw new Error(`Button ${j} in group ${i} must have 'type', 'value', and 'label'`);
                            }
                        });
                    });
                    
                    // Save and apply config
                    currentConfig = newConfig;
                    saveConfig(currentConfig);
                    emojiMap = buildEmojiMap(currentConfig);
                    renderButtons();
                    updateEventTypeFilter();
                    updateDailyReport();
                    updateButtonStates();
                    hideConfigEditor();
                    updateTimestamp("Configuration updated");
                } catch (e) {
                    errorDiv.textContent = "Error: " + e.message;
                    errorDiv.style.display = "block";
                }
            }

            // Create emoji lookup map from config
            function buildEmojiMap(config) {
                const emojiMap = {};
                config.groups.forEach((group) => {
                    group.buttons.forEach((btn) => {
                        if (!emojiMap[btn.type]) emojiMap[btn.type] = {};
                        emojiMap[btn.type][btn.value] = btn.emoji || "â€¢";
                    });
                });
                // Add emoji for notes
                emojiMap["note"] = { "": "ðŸ“" };
                return emojiMap;
            }

            let emojiMap = buildEmojiMap(currentConfig);

            // Update event type filter options based on config
            function updateEventTypeFilter() {
                const select = document.getElementById("event-type-filter");
                if (!select) return;

                // Keep "All Types" option and clear the rest
                select.innerHTML = '<option value="">All Types</option>';

                // Get unique types from config
                const types = new Set();
                currentConfig.groups.forEach((group) => {
                    group.buttons.forEach((btn) => {
                        types.add(btn.type);
                    });
                });

                // Add option for each type
                Array.from(types).sort().forEach((type) => {
                    const option = document.createElement("option");
                    option.value = type;
                    option.textContent = type.charAt(0).toUpperCase() + type.slice(1);
                    select.appendChild(option);
                });

                // Add notes option
                const notesOption = document.createElement("option");
                notesOption.value = "note";
                notesOption.textContent = "Notes";
                select.appendChild(notesOption);
            }

            // Generate buttons dynamically from config
            function renderButtons() {
                const container = document.querySelector(".container");
                const h2 = container.querySelector("h2");

                // Update title
                h2.textContent = currentConfig.title || "Activity Tracker";

                // Remove existing button cards
                const existingCards = container.querySelectorAll(
                    ".card:not(#daily-report .card)"
                );
                existingCards.forEach((card) => {
                    if (!card.querySelector("#notes")) {
                        card.remove();
                    }
                });

                // Insert button groups after the h2 (in reverse so they appear in correct order)
                [...currentConfig.groups].reverse().forEach((group) => {
                    const card = document.createElement("div");
                    card.className = "card";

                    const row = document.createElement("div");
                    row.className = "row";

                    group.buttons.forEach((btn) => {
                        const button = document.createElement("button");
                        button.className = "action";
                        button.dataset.type = btn.type;
                        button.dataset.value = btn.value;
                        button.dataset.stateful = group.stateful || false;
                        button.textContent = btn.label;
                        button.onclick = function () {
                            save(btn.type, btn.value, this);
                        };
                        button.onpointerdown = function (e) {
                            handleLongPressStart(btn.type, btn.value, this, e);
                        };
                        button.onpointerup = handleLongPressEnd;
                        button.onpointercancel = handleLongPressEnd;

                        row.appendChild(button);
                    });

                    card.appendChild(row);
                    h2.insertAdjacentElement("afterend", card);
                });
            }

            async function updateDailyReport() {
                const allEntries = await loadEntriesByDate(currentReportDate);

                // Filter out deleted entries for graphs/stats only
                const activeEntries = allEntries.filter((e) => !e.deleted);

                // Filter to only entries within the current day
                const entriesInDay = filterEntriesInDay(
                    allEntries,
                    currentReportDate
                );
                const activeEntriesInDay = filterEntriesInDay(
                    activeEntries,
                    currentReportDate
                );

                // Calculate statistics (uses activeEntries for cross-midnight sleep)
                const stats = calculateDailyStats(activeEntries);
                updateStatsDisplay(stats);

                // Display functions - graphs use active entries only, log uses all entries
                updateHourlyGrid(activeEntriesInDay);
                updateStateChanges(activeEntriesInDay);
                updateRecentEvents(entriesInDay); // Pass all entries including deleted

                // Timeline needs activeEntries to show cross-midnight sleep properly
                drawTimeline(activeEntries);
            }

            function calculateDailyStats(entries) {
                const stats = {};

                // Get day boundaries for clipping
                const { dayStart, dayEnd } = getDayBoundsAsDate(currentReportDate);

                // Calculate stats for each group based on config
                currentConfig.groups.forEach((group) => {
                    // For stateful groups, calculate duration per state
                    if (group.stateful) {
                        const stateEvents = entries.filter((e) => 
                            group.buttons.some(btn => btn.type === e.type)
                        );

                        // Initialize minutes counter for each state
                        const stateMinutes = {};
                        group.buttons.forEach(btn => {
                            stateMinutes[btn.value] = 0;
                        });

                        let currentState = null;
                        let currentStateStart = null;

                        // Check if day starts during a state
                        const eventsBeforeDay = stateEvents.filter(
                            (e) => new Date(e.ts) < dayStart
                        );
                        if (eventsBeforeDay.length > 0) {
                            const lastEventBeforeDay = eventsBeforeDay[eventsBeforeDay.length - 1];
                            currentState = lastEventBeforeDay.value;
                            currentStateStart = new Date(lastEventBeforeDay.ts);
                        }

                        stateEvents.forEach((event) => {
                            // End previous state
                            if (currentStateStart && currentState) {
                                const endTime = new Date(event.ts);
                                const clippedStart = currentStateStart < dayStart ? dayStart : currentStateStart;
                                const clippedEnd = endTime > dayEnd ? dayEnd : endTime;

                                if (clippedEnd > clippedStart) {
                                    const duration = (clippedEnd - clippedStart) / 1000 / 60;
                                    stateMinutes[currentState] += duration;
                                }
                            }
                            
                            // Start new state
                            currentState = event.value;
                            currentStateStart = new Date(event.ts);
                        });

                        // Handle ongoing state
                        if (currentStateStart && currentState) {
                            const now = new Date();
                            const reportDate = currentReportDate;
                            const isToday = reportDate.toDateString() === now.toDateString();

                            if (isToday) {
                                const clippedStart = currentStateStart < dayStart ? dayStart : currentStateStart;
                                const clippedEnd = now > dayEnd ? dayEnd : now;

                                if (clippedEnd > clippedStart) {
                                    const duration = (clippedEnd - clippedStart) / 1000 / 60;
                                    stateMinutes[currentState] += duration;
                                }
                            } else {
                                const clippedStart = currentStateStart < dayStart ? dayStart : currentStateStart;
                                if (dayEnd > clippedStart) {
                                    const duration = (dayEnd - clippedStart) / 1000 / 60;
                                    stateMinutes[currentState] += duration;
                                }
                            }
                        }

                        // Store state breakdown
                        stats[group.name] = { 
                            type: 'stateful',
                            states: Object.entries(stateMinutes).map(([state, mins]) => {
                                const hours = Math.floor(mins / 60);
                                const minutes = Math.round(mins % 60);
                                return { state, value: `${hours}h ${minutes}m`, minutes: mins };
                            }).filter(s => s.minutes > 0) // Only show states with time
                        };
                    }

                    // For counted groups or buttons, count events in the day
                    if (group.counted) {
                        const typeSet = new Set(group.buttons.map(btn => btn.type));
                        const count = entries.filter((e) => {
                            return typeSet.has(e.type) && isEntryInDay(e, dayStart, dayEnd);
                        }).length;
                        stats[group.name] = { value: count, type: 'count' };
                    } else {
                        // Check for individual counted buttons within non-counted groups
                        group.buttons.forEach((btn) => {
                            if (btn.counted) {
                                const count = entries.filter((e) => {
                                    return e.type === btn.type && 
                                           e.value === btn.value && 
                                           isEntryInDay(e, dayStart, dayEnd);
                                }).length;
                                stats[btn.label] = { value: count, type: 'count' };
                            }
                        });
                    }
                });

                return stats;
            }

            function updateStatsDisplay(stats) {
                // Build stat data from stats object
                const statData = [];
                Object.entries(stats).forEach(([label, data]) => {
                    if (data.type === 'stateful') {
                        // For stateful groups, add each state as a separate card
                        data.states.forEach(stateData => {
                            statData.push({
                                id: 'stat-' + label.toLowerCase().replace(/[^a-z0-9]/g, '-') + '-' + stateData.state.toLowerCase().replace(/[^a-z0-9]/g, '-'),
                                value: stateData.value,
                                label: `${label}: ${stateData.state}`,
                                isNumeric: false
                            });
                        });
                    } else {
                        statData.push({
                            id: 'stat-' + label.toLowerCase().replace(/[^a-z0-9]/g, '-'),
                            value: data.value,
                            label: label,
                            isNumeric: data.type === 'count'
                        });
                    }
                });

                // Clear and rebuild stats grid
                const statsGrid = d3.select('.stats-grid');
                statsGrid.selectAll('.stat-card').remove();

                const statCards = statsGrid.selectAll('.stat-card')
                    .data(statData)
                    .enter()
                    .append('div')
                    .attr('class', 'stat-card');

                statCards.append('div')
                    .attr('class', 'label')
                    .text(d => d.label);

                const values = statCards.append('div')
                    .attr('class', 'value')
                    .attr('id', d => d.id);

                // Animate numeric values
                values.each(function(d) {
                    const element = d3.select(this);
                    if (d.isNumeric) {
                        element
                            .transition()
                            .duration(500)
                            .tween("text", function() {
                                const i = d3.interpolateNumber(0, d.value);
                                return function(t) {
                                    this.textContent = Math.round(i(t));
                                };
                            });
                    } else {
                        element.text(d.value);
                    }
                });
            }

            function updateHourlyGrid(entries) {
                for (let hour = 0; hour < 24; hour++) {
                    const hourEntries = entries.filter((e) => {
                        const entryHour = new Date(e.ts).getHours();
                        return entryHour === hour;
                    });

                    const indicators = ["feed", "sleep", "wet", "dirty"];
                    indicators.forEach((type) => {
                        const el = document.getElementById(
                            `hour-${hour}-${type}`
                        );
                        if (el) {
                            const hasEvent = hourEntries.some((e) => {
                                if (type === "feed")
                                    return (
                                        e.type === "feed" && e.value === "bf"
                                    );
                                if (type === "sleep")
                                    return (
                                        e.type === "sleep" &&
                                        (e.value === "sleeping" ||
                                            e.value === "nap")
                                    );
                                if (type === "wet" || type === "dirty")
                                    return (
                                        e.type === "nappy" && e.value === type
                                    );
                                return e.type === type;
                            });
                            el.style.opacity = hasEvent ? "1" : "0.2";
                        }
                    });
                }
            }

            function updateStateChanges(entries) {
                // Find first stateful group
                const statefulGroup = currentConfig.groups.find(g => g.stateful);
                if (!statefulGroup) {
                    // Hide the section if no stateful groups
                    const section = document.querySelector('.sleep-attempts');
                    if (section) section.style.display = 'none';
                    return;
                }

                // Show the section
                const section = document.querySelector('.sleep-attempts');
                if (section) section.style.display = 'block';

                // Update section title
                const title = section.querySelector('h4');
                if (title) title.textContent = `${statefulGroup.name} Sessions`;

                const stateEvents = entries.filter((e) => 
                    statefulGroup.buttons.some(btn => btn.type === e.type)
                );

                // Determine which values are "active" states (first buttons) vs "inactive" (last button typically)
                const activeValues = statefulGroup.buttons
                    .filter((btn, idx) => idx < statefulGroup.buttons.length - 1)
                    .map(btn => btn.value);

                const sessions = [];
                let currentSession = null;

                stateEvents.forEach((event) => {
                    if (activeValues.includes(event.value)) {
                        if (currentSession) {
                            sessions.push(currentSession);
                        }
                        currentSession = {
                            start: new Date(event.ts),
                            type: event.value,
                        };
                    } else if (currentSession) {
                        currentSession.end = new Date(event.ts);
                        const duration = (currentSession.end - currentSession.start) / 1000 / 60;
                        currentSession.success = duration > 15; // More than 15 minutes = success
                        sessions.push(currentSession);
                        currentSession = null;
                    }
                });

                if (currentSession) {
                    currentSession.success = true; // Still in state
                    sessions.push(currentSession);
                }

                const container = d3.select("#sleep-attempts-list");

                // Add unique IDs for D3 data binding
                const sessionsWithIds = sessions.map((session, index) => ({
                    ...session,
                    sessionId: `${session.start.getTime()}-${index}`,
                }));

                // D3 data binding
                const sessionElements = container
                    .selectAll(".attempt")
                    .data(sessionsWithIds, (d) => d.sessionId);

                // Remove exiting
                sessionElements
                    .exit()
                    .transition()
                    .duration(300)
                    .style("opacity", 0)
                    .style("height", "0px")
                    .style("padding", "0px")
                    .remove();

                // Add new
                const entering = sessionElements
                    .enter()
                    .append("div")
                    .attr("class", (d) => `attempt ${d.success ? "success" : "fail"}`)
                    .style("opacity", 0)
                    .style("transform", "scaleY(0.01)");

                // Update all
                const all = entering.merge(sessionElements);

                all
                    .attr("class", (d) => `attempt ${d.success ? "success" : "fail"}`)
                    .transition()
                    .duration(300)
                    .style("opacity", 1)
                    .style("transform", "");

                all.html((d) => {
                    const timeStr = d.start.toLocaleTimeString([], {
                        hour: "2-digit",
                        minute: "2-digit",
                    });
                    let durationStr = "";
                    if (d.end) {
                        const mins = Math.round((d.end - d.start) / 1000 / 60);
                        durationStr = `${mins}m`;
                    } else {
                        durationStr = "ongoing";
                    }

                    return `
                        <span>${timeStr} - ${d.type}</span>
                        <span>${durationStr} ${d.success ? "âœ“" : "âœ—"}</span>
                    `;
                });
            }

            function updateRecentEvents(entries) {
                // Store entries globally for filtering
                allDayEntries = entries;

                // Clear text and type filters but keep hide deleted checked by default
                d3.select("#event-filter").property("value", "");
                d3.select("#event-type-filter").property("value", "");

                // Apply current filter settings
                applyEventFilters();
            }

            function showEventDetails(entry, event) {
                // Create or select tooltip div
                let tooltip = d3.select("body").select(".event-tooltip");
                if (tooltip.empty()) {
                    tooltip = d3
                        .select("body")
                        .append("div")
                        .attr("class", "event-tooltip")
                        .style("position", "absolute")
                        .style("background", "var(--card)")
                        .style("padding", "12px")
                        .style("border-radius", "8px")
                        .style("box-shadow", "0 4px 12px rgba(0,0,0,0.2)")
                        .style("border", "1px solid var(--muted)")
                        .style("font-size", "14px")
                        .style("max-width", "250px")
                        .style("z-index", "1001")
                        .style("opacity", 0)
                        .style("pointer-events", "none");
                }

                const time = new Date(entry.ts);
                const fullTimeStr = time.toLocaleString();
                const elapsed = formatElapsedTime(time.getTime());

                tooltip.html(`
                    <strong>Entry #${entry.id}</strong><br>
                    <strong>Type:</strong> ${entry.type}<br>
                    <strong>Value:</strong> ${entry.value}<br>
                    <strong>Time:</strong> ${fullTimeStr}<br>
                    <strong>Elapsed:</strong> ${elapsed}<br>
                    <strong>Deleted:</strong> ${entry.deleted ? "Yes" : "No"}
                `);

                // Position tooltip near mouse - use the passed event object
                const [mouseX, mouseY] = d3.pointer(
                    event,
                    d3.select("body").node()
                );
                tooltip
                    .style("left", mouseX + 10 + "px")
                    .style("top", mouseY - 10 + "px")
                    .transition()
                    .duration(200)
                    .style("opacity", 1);

                // Hide tooltip after 3 seconds
                setTimeout(() => {
                    tooltip.transition().duration(300).style("opacity", 0);
                }, 3000);
            }

            function drawTimeline(entries) {
                const container = document.getElementById("timeline-chart");
                container.innerHTML = "";

                const width = container.clientWidth || 600;
                const margin = { top: 20, right: 20, bottom: 30, left: 60 };

                // Get all stateful groups from config
                const statefulGroups = currentConfig.groups.filter(g => g.stateful);
                
                // Calculate height based on number of stateful groups (60px per group + margins)
                const heightPerGroup = 60;
                const height = Math.max(150, statefulGroups.length * heightPerGroup + margin.top + margin.bottom + 40);

                const svg = d3
                    .select("#timeline-chart")
                    .append("svg")
                    .attr("width", width)
                    .attr("height", height);

                // Get day boundaries
                const { dayStart, dayEnd } =
                    getDayBoundsAsDate(currentReportDate);

                // Filter to entries we care about for display
                const dayStart12HoursBefore = new Date(
                    dayStart.getTime() - 12 * 60 * 60 * 1000
                );
                const dayEnd12HoursAfter = new Date(
                    dayEnd.getTime() + 12 * 60 * 60 * 1000
                );

                const relevantEntries = entries.filter((e) => {
                    const ts = new Date(e.ts);
                    return (
                        ts >= dayStart12HoursBefore && ts <= dayEnd12HoursAfter
                    );
                });

                if (relevantEntries.length === 0) {
                    svg.append("text")
                        .attr("x", width / 2)
                        .attr("y", height / 2)
                        .attr("text-anchor", "middle")
                        .style("fill", getComputedStyle(document.documentElement).getPropertyValue('--text-muted'))
                        .text("No data for this day");
                    return;
                }

                // Create scales
                const x = d3
                    .scaleLinear()
                    .domain([0, 24])
                    .range([margin.left, width - margin.right]);

                // Draw gridlines for every hour
                for (let hour = 0; hour <= 24; hour++) {
                    svg.append("line")
                        .attr("x1", x(hour))
                        .attr("x2", x(hour))
                        .attr("y1", margin.top)
                        .attr("y2", height - margin.bottom)
                        .attr("stroke", "#e0e0e0")
                        .attr("stroke-width", 1)
                        .attr("opacity", 0.5);
                }

                // Draw X-axis with fewer ticks (every 3 hours)
                svg.append("g")
                    .attr("transform", `translate(0,${height - margin.bottom})`)
                    .call(
                        d3
                            .axisBottom(x)
                            .ticks(8)
                            .tickValues([0, 3, 6, 9, 12, 15, 18, 21, 24])
                            .tickFormat((d) => d + "h")
                    );

                const axisColor = getComputedStyle(document.documentElement).getPropertyValue('--text-muted');

                // Process each stateful group
                statefulGroups.forEach((group, groupIndex) => {
                    // Calculate Y range for this group
                    const groupTop = margin.top + groupIndex * heightPerGroup;
                    const groupBottom = groupTop + heightPerGroup - 10;
                    
                    const numStates = group.buttons.length;
                    const y = d3
                        .scaleLinear()
                        .domain([0, numStates])
                        .range([groupBottom, groupTop]);

                    // Add group label on left
                    svg.append("text")
                        .attr("x", 5)
                        .attr("y", (groupTop + groupBottom) / 2)
                        .attr("text-anchor", "start")
                        .attr("alignment-baseline", "middle")
                        .style("font-size", "12px")
                        .style("font-weight", "600")
                        .style("fill", axisColor)
                        .text(group.name);

                    // Get events for this group
                    const groupEvents = [];
                    relevantEntries.forEach((e) => {
                        if (group.buttons.some(btn => btn.type === e.type && btn.value === e.value)) {
                            const date = new Date(e.ts);
                            const hours = (date - dayStart) / (1000 * 60 * 60);
                            groupEvents.push({
                                time: hours,
                                value: e.value,
                                ts: date,
                            });
                        }
                    });

                    // Build line data
                    const lineData = [];
                    
                    // Determine initial state
                    const eventsBeforeDay = groupEvents.filter((e) => e.time < 0);
                    let currentState = null;
                    if (eventsBeforeDay.length > 0) {
                        const lastEventBeforeDay = eventsBeforeDay[eventsBeforeDay.length - 1];
                        currentState = lastEventBeforeDay.value;
                        const stateIndex = group.buttons.findIndex(btn => btn.value === currentState);
                        if (stateIndex >= 0) {
                            lineData.push({ time: 0, state: stateIndex + 0.5 });
                        }
                    }

                    groupEvents.forEach((event) => {
                        const hour = Math.max(0, Math.min(24, event.time));
                        if (hour >= 0 && hour <= 24) {
                            const stateIndex = group.buttons.findIndex(btn => btn.value === event.value);
                            if (stateIndex >= 0) {
                                lineData.push({ time: hour, state: stateIndex + 0.5 });
                                currentState = event.value;
                            }
                        }
                    });

                    // Determine end time
                    const now = new Date();
                    const isToday = currentReportDate.toDateString() === now.toDateString();
                    const endTime = isToday ? now.getHours() + now.getMinutes() / 60 : 24;

                    if (lineData.length > 0) {
                        lineData.push({ time: endTime, state: lineData[lineData.length - 1].state });
                    }

                    // Sort by time
                    lineData.sort((a, b) => a.time - b.time);

                    if (lineData.length > 0) {
                        // Create line generator
                        const line = d3
                            .line()
                            .x((d) => x(d.time))
                            .y((d) => y(d.state))
                            .curve(d3.curveStepAfter);

                        // Draw the state line
                        svg.append("path")
                            .datum(lineData)
                            .attr("fill", "none")
                            .attr("stroke", "#2196f3")
                            .attr("stroke-width", 2)
                            .attr("d", line);

                        // Draw shaded areas for each state
                        group.buttons.forEach((btn, btnIndex) => {
                            const stateValue = btnIndex + 0.5;
                            const stateSegments = [];
                            let inState = false;
                            let segmentStart = null;

                            lineData.forEach((point, i) => {
                                if (point.state === stateValue) {
                                    if (!inState) {
                                        segmentStart = point.time;
                                        inState = true;
                                    }
                                } else if (inState) {
                                    stateSegments.push({ start: segmentStart, end: point.time });
                                    inState = false;
                                }
                            });

                            if (inState) {
                                stateSegments.push({ start: segmentStart, end: endTime });
                            }

                            // Draw rectangles for each segment
                            stateSegments.forEach(seg => {
                                svg.append("rect")
                                    .attr("x", x(seg.start))
                                    .attr("y", y(stateValue + 0.4))
                                    .attr("width", x(seg.end) - x(seg.start))
                                    .attr("height", y(stateValue - 0.4) - y(stateValue + 0.4))
                                    .attr("fill", "#2196f3")
                                    .attr("fill-opacity", 0.15);
                            });
                        });
                    }

                    // Add Y-axis labels for states
                    group.buttons.forEach((btn, btnIndex) => {
                        svg.append("text")
                            .attr("x", margin.left - 5)
                            .attr("y", y(btnIndex + 0.5))
                            .attr("text-anchor", "end")
                            .attr("alignment-baseline", "middle")
                            .style("font-size", "10px")
                            .style("fill", axisColor)
                            .text(btn.value);
                    });
                });

                // Draw non-stateful events as emoji text - distribute vertically
                const eventData = [];
                relevantEntries.forEach((e) => {
                    const date = new Date(e.ts);
                    const hours = (date - dayStart) / (1000 * 60 * 60);
                    
                    // Skip if this is a stateful group event
                    const isStateful = statefulGroups.some(g => 
                        g.buttons.some(btn => btn.type === e.type && btn.value === e.value)
                    );
                    
                    if (!isStateful && hours >= 0 && hours < 24) {
                        let emoji = "â€¢";
                        if (emojiMap[e.type]) {
                            emoji = emojiMap[e.type][e.value] || emojiMap[e.type][""] || "â€¢";
                        }
                        eventData.push({
                            time: hours,
                            emoji: emoji,
                            type: e.type,
                            value: e.value,
                        });
                    }
                });

                // Space out emojis vertically by offsetting based on hash
                const emojiYBase = height - margin.bottom - 10;
                const emojiSpacing = 18;
                const numLevels = 10;
                
                // Simple hash function for strings
                function hashString(str) {
                    let hash = 0;
                    for (let i = 0; i < str.length; i++) {
                        hash = ((hash << 5) - hash) + str.charCodeAt(i);
                        hash = hash & hash; // Convert to 32bit integer
                    }
                    return Math.abs(hash);
                }
                
                eventData.forEach((d, i) => {
                    // Calculate vertical offset - choose level based on hash of type+value
                    const hashInput = `${d.type}:${d.value}`;
                    const level = hashString(hashInput) % numLevels;
                    const yOffset = level * (emojiSpacing / 2);
                    
                    svg.append("text")
                        .attr("x", x(d.time))
                        .attr("y", emojiYBase - yOffset)
                        .attr("text-anchor", "middle")
                        .attr("dominant-baseline", "middle")
                        .style("font-size", "16px")
                        .style("cursor", "pointer")
                        .text(d.emoji)
                        .append("title")
                        .text(`${d.type}: ${d.value}`);
                });
            }
        </script>
    </head>

    <body>
        <button id="settings-btn" onclick="showConfigEditor()" title="Settings">âš™ï¸</button>
        
        <div class="container">
            <h2>Baby Daily Log</h2>

            <!-- Buttons will be dynamically generated here -->

            <div class="card">
                <input
                    type="text"
                    id="notes"
                    placeholder="Notes - type and press Enter"
                />
                <small id="laststamp" class="timestamp">Not yet saved</small>
            </div>

            <div style="display: flex; gap: 8px">
                <div style="flex: 1"></div>
            </div>

            <div id="daily-report">
                <h3>Daily Report</h3>

                <div id="date-selector">
                    <button onclick="changeReportDate(-1)">â—€ Prev</button>
                    <input
                        type="date"
                        id="report-date"
                        onchange="setReportDate(this.value)"
                    />
                    <button onclick="changeReportDate(1)">Next â–¶</button>
                    <button onclick="goToToday()">Today</button>
                </div>

                <div class="tab-container">
                    <div class="tab-buttons">
                        <button
                            class="tab-btn active"
                            data-tab="log"
                            onclick="switchTab('log')"
                        >
                            Event Log
                        </button>
                        <button
                            class="tab-btn"
                            data-tab="graphs"
                            onclick="switchTab('graphs')"
                        >
                            Graphs & Stats
                        </button>
                    </div>

                    <div class="tabs-wrapper">
                    <div id="log-tab" class="tab-content active">
                        <div class="recent-events">
                            <h4>
                                Events
                                <div
                                    style="
                                        display: flex;
                                        gap: 8px;
                                        align-items: center;
                                        margin-top: 8px;
                                    "
                                >
                                    <button
                                        class="btn"
                                        id="download"
                                        onclick="downloadCSV()"
                                        style="margin: 0"
                                    >
                                        Download CSV
                                    </button>
                                    <input
                                        type="text"
                                        id="event-filter"
                                        placeholder="Filter events..."
                                        style="
                                            flex: 1;
                                            padding: 6px 10px;
                                            font-size: 12px;
                                            border-radius: 4px;
                                            border: 1px solid var(--border);
                                            background: var(--card);
                                            color: var(--text);
                                        "
                                    />
                                    <select
                                        id="event-type-filter"
                                        style="
                                            padding: 6px;
                                            font-size: 12px;
                                            border-radius: 4px;
                                            border: 1px solid var(--border);
                                            background: var(--card);
                                            color: var(--text);
                                        "
                                    >
                                        <option value="">All Types</option>
                                        <!-- Will be populated by JS -->
                                    </select>
                                    <label
                                        style="
                                            display: flex;
                                            align-items: center;
                                            gap: 4px;
                                            font-size: 12px;
                                            white-space: nowrap;
                                        "
                                    >
                                        <input
                                            type="checkbox"
                                            id="hide-deleted-filter"
                                            checked
                                        />
                                        Hide deleted
                                    </label>
                                </div>
                            </h4>

                            <div class="event-list" id="recent-events-list">
                                <!-- Will be populated by JS -->
                            </div>
                        </div>
                    </div>

                    <div id="graphs-tab" class="tab-content">
                        <div class="stats-grid">
                            <div class="stat-card">
                                <div class="label">Total Sleep</div>
                                <div class="value" id="stat-sleep">0h 0m</div>
                            </div>
                            <div class="stat-card">
                                <div class="label">Feeds</div>
                                <div class="value" id="stat-feeds">0</div>
                            </div>
                            <div class="stat-card">
                                <div class="label">Wet Nappies</div>
                                <div class="value" id="stat-wet">0</div>
                            </div>
                            <div class="stat-card">
                                <div class="label">Dirty Nappies</div>
                                <div class="value" id="stat-dirty">0</div>
                            </div>
                        </div>

                        <h4
                            style="
                                font-size: 14px;
                                margin: 16px 0 8px 0;
                                color: var(--text-muted);
                            "
                        >
                            Hourly Activity
                        </h4>
                        <div class="hourly-grid" id="hourly-grid">
                            <!-- Will be populated by JS -->
                        </div>

                        <div id="timeline-chart"></div>

                        <div class="sleep-attempts">
                            <h4>State Sessions</h4>
                            <div class="attempt-list" id="sleep-attempts-list">
                                <!-- Will be populated by JS -->
                            </div>
                        </div>
                    </div>
                    </div>
                </div>
            </div>

            <script>
                // Initialize date selector to today
                const today = new Date();
                const year = today.getFullYear();
                const month = String(today.getMonth() + 1).padStart(2, "0");
                const day = String(today.getDate()).padStart(2, "0");
                document.getElementById(
                    "report-date"
                ).value = `${year}-${month}-${day}`;

                // Build hourly grid
                const hourlyGrid = document.getElementById("hourly-grid");

                // Add empty cell for top-left corner
                const corner = document.createElement("div");
                hourlyGrid.appendChild(corner);

                // Add hour labels across the top
                for (let hour = 0; hour < 24; hour++) {
                    const label = document.createElement("div");
                    label.className = "hour-label";
                    label.textContent = hour;
                    hourlyGrid.appendChild(label);
                }

                // Add rows with labels
                const rows = [
                    { label: "Feed", type: "feed" },
                    { label: "Sleep", type: "sleep" },
                    { label: "Wet", type: "wet" },
                    { label: "Dirty", type: "dirty" },
                ];

                rows.forEach((row) => {
                    // Add row label
                    const rowLabel = document.createElement("div");
                    rowLabel.className = "row-label";
                    rowLabel.textContent = row.label;
                    hourlyGrid.appendChild(rowLabel);

                    // Add indicators for each hour
                    for (let hour = 0; hour < 24; hour++) {
                        const indicator = document.createElement("div");
                        indicator.className = `hour-indicator ${row.type}`;
                        indicator.id = `hour-${hour}-${row.type}`;
                        indicator.title = `${row.label} at ${hour}:00`;
                        hourlyGrid.appendChild(indicator);
                    }
                });

                initDB().then(() => {
                    renderButtons();
                    updateEventTypeFilter();
                    updateDailyReport();
                    updateButtonStates();
                    updateUndoRedoButtons();

                    // Setup event filters
                    d3.select("#event-filter").on("input", applyEventFilters);
                    d3.select("#event-type-filter").on(
                        "change",
                        applyEventFilters
                    );
                    d3.select("#hide-deleted-filter").on(
                        "change",
                        applyEventFilters
                    );
                });

                let allDayEntries = []; // Store all entries for filtering

                function applyEventFilters() {
                    const textFilter = d3
                        .select("#event-filter")
                        .property("value")
                        .toLowerCase();
                    const typeFilter = d3
                        .select("#event-type-filter")
                        .property("value");
                    const hideDeleted = d3
                        .select("#hide-deleted-filter")
                        .property("checked");

                    const filteredEntries = allDayEntries.filter((e) => {
                        const matchesDeleted = !hideDeleted || !e.deleted;
                        const matchesType =
                            !typeFilter || e.type === typeFilter;
                        const matchesText =
                            !textFilter ||
                            e.type.toLowerCase().includes(textFilter) ||
                            e.value.toLowerCase().includes(textFilter);
                        return matchesDeleted && matchesType && matchesText;
                    });

                    updateRecentEventsDisplay(filteredEntries);
                }

                function updateRecentEventsDisplay(entries) {
                    const container = d3.select("#recent-events-list");
                    if (!container.node()) return;

                    // Show all events for the selected day in reverse chronological order
                    const allEvents = [...entries].reverse();

                    // D3 data binding using IndexedDB primary key
                    const eventEntries = container
                        .selectAll(".event-entry")
                        .data(allEvents, (d) => d.id); // Key by IndexedDB primary key

                    // Remove exiting events
                    eventEntries
                        .exit()
                        .style("overflow", "hidden")
                        .transition()
                        .duration(300)
                        .style("opacity", 0)
                        .style("max-height", "0px")
                        .style("margin-top", "0px")
                        .style("margin-bottom", "0px")
                        .style("padding-top", "0px")
                        .style("padding-bottom", "0px")
                        .remove();

                    // Add new events
                    const enteringEvents = eventEntries
                        .enter()
                        .append("div")
                        .attr(
                            "class",
                            (d) => `event-entry${d.deleted ? " deleted" : ""}`
                        )
                        .style("opacity", 0)
                        .style("max-height", "0px")
                        .style("overflow", "hidden")
                        .style("margin-top", "0px")
                        .style("margin-bottom", "0px")
                        .style("padding-top", "0px")
                        .style("padding-bottom", "0px");

                    // Update all events (both new and existing)
                    const allEventEntries = enteringEvents.merge(eventEntries);

                    allEventEntries
                        .attr(
                            "class",
                            (d) => `event-entry${d.deleted ? " deleted" : ""}`
                        )
                        .transition()
                        .duration(300)
                        .style("opacity", 1)
                        .style("max-height", "100px")
                        .style("overflow", "")
                        .style("margin-top", "")
                        .style("margin-bottom", "")
                        .style("padding-top", "")
                        .style("padding-bottom", "");

                    allEventEntries.html((d) => {
                        const timeStr = new Date(d.ts).toLocaleTimeString([], {
                            hour: "2-digit",
                            minute: "2-digit",
                        });
                        const deletedLabel = d.deleted
                            ? ' <small style="opacity: 0.6;">[deleted]</small>'
                            : "";
                        const actionBtn = d.deleted
                            ? `<button class="action-btn undelete-btn" data-id="${d.id}">â†¶</button>`
                            : `<button class="action-btn delete-btn" data-id="${d.id}">Ã—</button>`;

                        return `
                        <div style="display: flex; align-items: center; justify-content: space-between; width: 100%;">
                            <div>
                                <span class="event-type">${d.type}</span><span class="event-value">: ${d.value}</span>${deletedLabel}
                            </div>
                            <div style="display: flex; align-items: center;">
                                <span class="event-time">${timeStr}</span>${actionBtn}
                            </div>
                        </div>
                    `;
                    });

                    // Helper function for entry actions
                    const handleEntryAction = async (entry, action) => {
                        const result =
                            action === "delete"
                                ? await deleteEntry(entry.id)
                                : await undeleteEntry(entry.id);
                        if (result) {
                            const actionText =
                                action === "delete" ? "Deleted" : "Restored";
                            updateTimestamp(
                                `${actionText}: ${result.type} - ${result.value}`
                            );
                            updateDailyReport();
                            updateButtonStates();
                        }
                    };

                    // Add event interactions
                    allEventEntries
                        .style("cursor", "pointer")
                        .on("click", function (event, d) {
                            if (event.target.classList.contains("delete-btn")) {
                                event.stopPropagation();
                                handleEntryAction(d, "delete");
                            } else if (
                                event.target.classList.contains("undelete-btn")
                            ) {
                                event.stopPropagation();
                                handleEntryAction(d, "undelete");
                            } else {
                                showEventDetails(d, event);
                            }
                        })
                        .on(
                            "dblclick",
                            (event, d) =>
                                !d.deleted && handleEntryAction(d, "delete")
                        );
                }

                // this function generates several days worth of test data. it is lightly random.
                async function generateTestData() {
                    const days = 7; // Generate a week of data
                    const now = new Date();

                    for (let day = days - 1; day >= 0; day--) {
                        const baseDate = new Date(now);
                        baseDate.setDate(baseDate.getDate() - day);
                        baseDate.setHours(0, 0, 0, 0);

                        // Generate sleep patterns (roughly 3-4 sleep cycles per day)
                        const sleepCycles = 3 + Math.floor(Math.random() * 2);

                        for (let cycle = 0; cycle < sleepCycles; cycle++) {
                            // Sleep start time (spread throughout 24 hours)
                            const sleepHour = Math.floor(
                                (24 / sleepCycles) * cycle + Math.random() * 2
                            );
                            const sleepMinute = Math.floor(Math.random() * 60);

                            const sleepStart = new Date(baseDate);
                            sleepStart.setHours(sleepHour, sleepMinute);

                            // Sleep type: longer sleep at night, naps during day
                            const sleepType =
                                sleepHour >= 20 || sleepHour < 6
                                    ? "sleeping"
                                    : "nap";
                            await addEntry(
                                "sleep",
                                sleepType,
                                sleepStart.toISOString()
                            );

                            // Sleep duration: 30min to 3 hours for naps, 2-5 hours for night sleep
                            let durationMinutes;
                            if (sleepType === "nap") {
                                durationMinutes = 30 + Math.random() * 150;
                            } else {
                                durationMinutes = 120 + Math.random() * 180;
                            }

                            const awakeTime = new Date(sleepStart);
                            awakeTime.setMinutes(
                                awakeTime.getMinutes() + durationMinutes
                            );

                            // Sometimes add soothe methods before sleep
                            if (Math.random() > 0.5) {
                                const sootheBefore = new Date(sleepStart);
                                sootheBefore.setMinutes(
                                    sootheBefore.getMinutes() - 5
                                );
                                const sootheMethod = [
                                    "rocking",
                                    "pram",
                                    "wearing",
                                    "feed-to-sleep",
                                ][Math.floor(Math.random() * 4)];
                                await addEntry(
                                    "soothe",
                                    sootheMethod,
                                    sootheBefore.toISOString()
                                );
                            }

                            await addEntry(
                                "sleep",
                                "awake",
                                awakeTime.toISOString()
                            );
                        }

                        // Generate feeding events (every 2-4 hours, ~6-8 feeds per day)
                        const feedCount = 6 + Math.floor(Math.random() * 3);

                        for (let feed = 0; feed < feedCount; feed++) {
                            const feedHour = Math.floor(
                                (24 / feedCount) * feed + Math.random() * 2
                            );
                            const feedMinute = Math.floor(Math.random() * 60);

                            const feedTime = new Date(baseDate);
                            feedTime.setHours(feedHour, feedMinute);

                            await addEntry(
                                "feed",
                                "bf",
                                feedTime.toISOString()
                            );

                            // Sometimes spew after feeding
                            if (Math.random() > 0.7) {
                                const spewTime = new Date(feedTime);
                                spewTime.setMinutes(
                                    spewTime.getMinutes() +
                                        10 +
                                        Math.random() * 30
                                );
                                await addEntry(
                                    "feed",
                                    "spew",
                                    spewTime.toISOString()
                                );
                            }

                            // Occasional grizzle
                            if (Math.random() > 0.8) {
                                const grizzleTime = new Date(feedTime);
                                grizzleTime.setMinutes(
                                    grizzleTime.getMinutes() -
                                        5 -
                                        Math.random() * 10
                                );
                                await addEntry(
                                    "feed",
                                    "grizzle",
                                    grizzleTime.toISOString()
                                );
                            }
                        }

                        // Generate Nappy changes (roughly 6-10 per day)
                        const NappyCount = 6 + Math.floor(Math.random() * 5);

                        for (let Nappy = 0; Nappy < NappyCount; Nappy++) {
                            const NappyHour = Math.floor(
                                (24 / NappyCount) * Nappy + Math.random() * 2
                            );
                            const NappyMinute = Math.floor(Math.random() * 60);

                            const NappyTime = new Date(baseDate);
                            NappyTime.setHours(NappyHour, NappyMinute);

                            // Most Nappies are wet
                            await addEntry(
                                "nappy",
                                "wet",
                                NappyTime.toISOString()
                            );

                            // About half are also dirty
                            if (Math.random() > 0.5) {
                                await addEntry(
                                    "nappy",
                                    "dirty",
                                    NappyTime.toISOString()
                                );
                            }
                        }

                        // Occasional use of 5 S's techniques
                        const fiveSCount = Math.floor(Math.random() * 4);
                        for (let i = 0; i < fiveSCount; i++) {
                            const fiveSHour = Math.floor(Math.random() * 24);
                            const fiveSMinute = Math.floor(Math.random() * 60);

                            const fiveSTime = new Date(baseDate);
                            fiveSTime.setHours(fiveSHour, fiveSMinute);

                            const technique = [
                                "swaddle",
                                "side-lying",
                                "shush",
                                "swing",
                                "suck",
                            ][Math.floor(Math.random() * 5)];
                            await addEntry(
                                "5s",
                                technique,
                                fiveSTime.toISOString()
                            );
                        }

                        // Add occasional notes
                        if (Math.random() > 0.6) {
                            const noteHour = Math.floor(Math.random() * 24);
                            const noteMinute = Math.floor(Math.random() * 60);

                            const noteTime = new Date(baseDate);
                            noteTime.setHours(noteHour, noteMinute);

                            const notes = [
                                "Good day!",
                                "A bit fussy today",
                                "Slept well",
                                "Cluster feeding",
                                "Very alert and happy",
                                "Seems gassy",
                                "Long stretch of sleep!",
                                "Growth spurts?",
                            ];
                            await addEntry(
                                "note",
                                notes[Math.floor(Math.random() * notes.length)],
                                noteTime.toISOString()
                            );
                        }
                    }

                    console.log(`Generated ${days} days of test data`);
                    await updateDailyReport();
                }
            </script>
        </div>

        <div
            id="time-picker-modal"
            class="modal-overlay"
            onclick="if(event.target === this) hideTimePicker()"
        >
            <div class="modal">
                <h3>Select Time</h3>
                <input type="datetime-local" id="custom-time" />
                <div class="modal-buttons">
                    <button class="cancel" onclick="hideTimePicker()">
                        Cancel
                    </button>
                    <button class="confirm" onclick="saveWithCustomTime()">
                        Save
                    </button>
                </div>
            </div>
        </div>

        <div
            id="config-editor-modal"
            class="modal-overlay"
            onclick="if(event.target === this) hideConfigEditor()"
        >
            <div class="modal config-editor">
                <h3>Configuration Editor</h3>
                <div class="config-templates">
                    <button onclick="loadTemplate('baby')">Baby Template</button>
                    <button onclick="loadTemplate('warehouse')">Warehouse Template</button>
                    <button onclick="loadTemplate('lab')">Lab Template</button>
                </div>
                <textarea id="config-json" spellcheck="false"></textarea>
                <div id="config-error" class="config-error"></div>
                <div class="modal-buttons" style="margin-top: 12px;">
                    <button class="cancel" onclick="hideConfigEditor()">
                        Cancel
                    </button>
                    <button class="confirm" onclick="saveConfigFromEditor()">
                        Save Configuration
                    </button>
                </div>
            </div>
        </div>
    </body>
</html>
