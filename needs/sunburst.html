<!DOCTYPE html>
<meta charset="utf-8">
<style>
path {
  stroke: #fff;
}
</style>

<body>
  <button type="button" onclick="swapProjection()">click me</button>
  <button type="button" onclick="load('feelings-tree.tsv')">set 1</button>
  <button type="button" onclick="load('feelings-tree2.tsv')">set 2</button>
  <button type="button" onclick="load('feelings-tree3.tsv')">set 3</button>
  <button type="button" onclick="load('feelings-tree4.tsv')">set 4</button>
  <br />
  <svg />
  <script src="https://d3js.org/d3.v4.min.js"></script>
  <script>
  var width = 800,
    height = 800,
    padding = 10
  radius = (Math.min(width, height) / 2) - padding;

  var formatNumber = d3.format(",d");

  var angle = 0.0;
  var τ = 2 * Math.PI;
  //var x = d3.scaleLinear().range([0, 2 * Math.PI]);
  var projections = {
    radial: {
      name: "radial",
      x: a => (a * τ) + angle, // 0..1 -> 0..τ,
      y: d3.scalePow() // 0..1 -> 0..r
        .exponent(1.5)
        .range([0, radius]),
      shape: d3.arc()
        .startAngle(d => projections.radial.x(d.x0))
        .endAngle(d => projections.radial.x(d.x1))
        .innerRadius(d => Math.max(0, projections.radial.y(d.y0)))
        .outerRadius(d => Math.max(0, projections.radial.y(d.y1))),
      translate: d => pointRadial(projections.radial.x(d.x), projections.radial.y(d.y)),
      rotate: d => {
        let θ = projections.radial.x(d.x);
        return θ * 360 / τ + ((θ % τ) > Math.PI ? 90 : -90);
      }
    },
    cartesian: {
      name: "cartesian",
      x: d3.scaleLinear().range([-width / 2 + padding, width / 2 - padding]),
      y: d3.scaleLinear().range([-height / 2 + padding, height / 2 - padding]),
      shape: d => d3.line()
        .curve(d3.curveLinearClosed)
        ([
          [projections.cartesian.x(d.y0), projections.cartesian.y(d.x0)],
          [projections.cartesian.x(d.y0), projections.cartesian.y(d.x1)],
          [projections.cartesian.x(d.y1), projections.cartesian.y(d.x1)],
          [projections.cartesian.x(d.y1), projections.cartesian.y(d.x0)]
        ]),
      translate: d => [projections.cartesian.x(d.y), projections.cartesian.y(d.x)],
      rotate: d => 0
    }
  };
  var p = projections.radial;
  var currentProjection = p.name;
  var ycolor = d3.scaleLinear().domain([0, 1]).range([1.5 * radius, 0.1 * radius]);

  var range100 = d3.scaleLinear().range([0, 100]);
  var interval, interval2;
  var duration = 5000;

  var stratify = d3.stratify()
    .id(d => d.Index)
    .parentId(d => d.Parent);

  var partition = d3.partition();

  var pointRadial = (θ, r) => [(r = +r) * Math.cos(θ -= Math.PI / 2), r * Math.sin(θ)];

  var easeBothWays = f => t => t % 1 < 0.5 ? f(Math.abs(t % 1) * 2) : f(2 * (1 - Math.abs(t % 1)));
  var cartesianToColorSpace = d3.scaleLinear().domain([-radius, radius]).range([-100, 100]);
  var color = d => {
    var p = pointRadial(
      (d.x * τ + 10 * angle) % τ,
      ycolor(d.y)
    );
    if (d.y == 0.0) p = [0, 0]; // root grey
    return d3.lab(70, cartesianToColorSpace(p[0]), cartesianToColorSpace(p[1]));
  }

  var svg = d3.select("body").selectAll("svg")
    .attr("width", width)
    .attr("height", height)
    .append("g")
    .attr("transform", "translate(" + width / 2 + "," + (height / 2) + ")");

  function load(fname) {    
    d3.tsv(fname, function(error, rows) {
      if (error) throw error;

      heirarchy = stratify(rows);
      heirarchy.count();
      root = partition(heirarchy);
      root.each(d => {
        d.x = (d.x0 + d.x1) / 2;
        d.y = (d.y0 + d.y1) / 2;
      });
      // root node centred and not rotated
      root.x = 0.25;
      root.y = 0.0;

      update(root);
    });
  }
  load('feelings-tree.tsv');

  function update(root) {
    let paths = svg.selectAll("path")
      .data(root.descendants(), d => d.data.Move);

    let newPaths = paths.enter().append("path")
      .attr("d", p.shape)
      .on("click", pathclick)
      .style("fill", d => "white");
    newPaths.append("title")
      .text(d => d.data.Move);

    paths.exit().remove();
    paths.merge(newPaths)
      .transition()
      .duration(5000)
      .attr("d", p.shape)
      .style("fill", d => color(d));

    let texts = svg.selectAll("g")
      .data(root.descendants(), d => d.data.Move);

    let newTexts = texts.enter().append("g")
      .attr("transform", d => "translate(0, 0) rotate(0)");

    newTexts
      .append("text")
      .text(d => d.data.Move)
      .attr("text-anchor", "middle")
      .attr("dominant-baseline", "central");

    texts.exit().remove();
    texts.merge(newTexts)
      .transition()
      .duration(5000)
      .attr("transform", d => "translate(" + p.translate(d) + ") rotate(" + p.rotate(d) + ")")

    svg.selectAll("path").node().onclick = () => interval ? stopInterval() : startInterval();
  }

  function pathclick(d) {
    let result = stopInterval();
    angle = τ * (1.25 - d.x);
    transition();
  }

  // returns true if interval was running
  function stopInterval() {
    let result = !!interval;
    if (interval) {
      interval.stop();
      interval2.stop();
      interval = null;
    }
    return result;
  }

  function startInterval() {
    if (interval) return;
    duration = 1000;
    interval = d3.interval(function() {
      angle += 0.01;
      angle %= τ;
      transition();
    }, 1000);
    interval2 = d3.interval(function() {
      let y = projections.radial.y
      y.exponent() == 1.8 ? y.exponent(1.2) : y.exponent(1.8);
    }, 10000);
  }

  function transition(name) {
    svg.selectAll("g") // text
      .transition(name)
      .ease(d3.easeLinear)
      .duration(duration)
      .attr("transform", d => "translate(" + p.translate(d) + ") rotate(" + p.rotate(d) + ")");

    var result = svg.selectAll("path") // arcs
      .transition(name)
      .ease(d3.easeLinear)
      .duration(duration)
      .style("fill", d => color(d));

    if (p.name === currentProjection)
      result.attr("d", p.shape);
    else
      result.attrTween("d", pathTween(10));

    currentProjection = p.name;

    return result;
  }

  // https://bl.ocks.org/mbostock/3916621
  function pathTween(precision) {
    return function(d) { // factory function
      var path0 = this,
        path1 = path0.cloneNode(),
        n0 = path0.getTotalLength(),
        n1 = (path1.setAttribute("d", p.shape(d)), path1).getTotalLength();

      // Uniform sampling of distance based on specified precision.
      var distances = [0],
        i = 0,
        dt = precision / Math.max(n0, n1);
      while ((i += dt) < 1) distances.push(i);
      distances.push(1);

      // Compute point-interpolators at each distance.
      var points = distances.map(function(t) {
        var p0 = path0.getPointAtLength(t * n0),
          p1 = path1.getPointAtLength(t * n1);
        return d3.interpolate([p0.x, p0.y], [p1.x, p1.y]);
      });

      return function(t) {
        return t < 1 ? "M" + points.map(function(p) {
          return p(t);
        }).join("L") : p.shape(d);
      };
    };
  }

  function swapProjection() {
    let restart = stopInterval();
    p = p.name === "radial" ? projections.cartesian : projections.radial;
    var t = transition();
    if (restart)
      t.on("end", startInterval);
  }


  d3.select(self.frameElement).style("height", height + "px");
  </script>
