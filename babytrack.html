<!DOCTYPE html>
<html lang="en">
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Baby Log</title>
        <script src="https://unpkg.com/d3@7"></script>
        <style>
            :root {
                --bg: #f7f7f7;
                --card: #fff;
                --muted: #e0e0e0;
                --primary: #4c84ff;
            }
            body {
                font-family: system-ui, -apple-system, Segoe UI, Roboto,
                    Helvetica, Arial;
                margin: 0;
                background: var(--bg);
            }
            .container {
                display: flex;
                flex-direction: column;
                height: 100vh;
                padding: 14px;
                box-sizing: border-box;
                gap: 10px;
            }
            h2 {
                margin: 0;
                font-size: 18px;
            }
            .card {
                background: var(--card);
                padding: 10px;
                border-radius: 12px;
                box-shadow: 0 1px 4px rgba(0, 0, 0, 0.06);
            }
            .row {
                display: flex;
                gap: 8px;
            }
            .action {
                flex: 1;
                padding: 14px;
                border-radius: 10px;
                border: 0;
                background: var(--muted);
                font-size: 15px;
                cursor: pointer;
                transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
            }
            .action.fading {
                transform: scale(0.85);
                background: var(--primary);
                color: #fff;
                box-shadow: 0 4px 12px rgba(76, 132, 255, 0.4);
            }
            .btn {
                padding: 12px;
                border-radius: 10px;
                border: 0;
                cursor: pointer;
                font-size: 15px;
            }
            #undo {
                background: #ff6666;
                color: #fff;
            }
            #download {
                background: #4caf50;
                color: #fff;
            }
            input[type="text"] {
                width: 100%;
                padding: 12px;
                border-radius: 8px;
                border: 1px solid #ddd;
                font-size: 15px;
                box-sizing: border-box;
            }
            small.timestamp {
                display: block;
                margin-top: 6px;
                color: #666;
                font-size: 12px;
            }
            #daily-report {
                background: var(--card);
                padding: 12px;
                border-radius: 12px;
                box-shadow: 0 1px 4px rgba(0, 0, 0, 0.06);
            }
            #daily-report h3 {
                margin: 0 0 12px 0;
                font-size: 16px;
                display: flex;
                justify-content: space-between;
                align-items: center;
            }
            #date-selector {
                display: flex;
                gap: 8px;
                align-items: center;
                margin-bottom: 12px;
            }
            #date-selector input[type="date"] {
                flex: 1;
                padding: 8px;
                border-radius: 6px;
                border: 1px solid #ddd;
                font-size: 14px;
            }
            #date-selector button {
                padding: 8px 12px;
                border-radius: 6px;
                border: 0;
                background: var(--muted);
                cursor: pointer;
                font-size: 14px;
            }
            .stats-grid {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
                gap: 10px;
                margin-bottom: 16px;
            }
            .stat-card {
                background: var(--bg);
                padding: 10px;
                border-radius: 8px;
                text-align: center;
            }
            .stat-card .label {
                font-size: 12px;
                color: #666;
                margin-bottom: 4px;
            }
            .stat-card .value {
                font-size: 20px;
                font-weight: 600;
                color: #333;
            }
            .hourly-grid {
                display: grid;
                grid-template-columns: auto repeat(24, 1fr);
                gap: 2px;
                margin-bottom: 16px;
                align-items: center;
            }
            .hour-col {
                display: flex;
                flex-direction: column;
                gap: 2px;
            }
            .row-label {
                font-size: 11px;
                color: #666;
                padding: 4px 8px 4px 0;
                text-align: right;
                white-space: nowrap;
            }
            .hour-label {
                font-size: 10px;
                text-align: center;
                color: #666;
                margin-bottom: 2px;
            }
            .hour-indicator {
                width: 100%;
                height: 20px;
                border-radius: 3px;
                background: var(--muted);
                position: relative;
            }
            .hour-indicator.feed {
                background: #4caf50;
            }
            .hour-indicator.sleep {
                background: #2196f3;
            }
            .hour-indicator.nap {
                background: #64b5f6;
            }
            .hour-indicator.wet {
                background: #ff9800;
            }
            .hour-indicator.dirty {
                background: #795548;
            }
            .hour-indicator.soothe {
                background: #9c27b0;
            }
            .sleep-attempts {
                margin-top: 12px;
            }
            .sleep-attempts h4 {
                font-size: 14px;
                margin: 0 0 8px 0;
                color: #666;
            }
            .attempt-list {
                display: flex;
                flex-direction: column;
                gap: 4px;
            }
            .attempt {
                padding: 6px 10px;
                background: var(--bg);
                border-radius: 6px;
                font-size: 13px;
                display: flex;
                justify-content: space-between;
            }
            .attempt.success {
                background: #e8f5e9;
                color: #2e7d32;
            }
            .attempt.fail {
                background: #ffebee;
                color: #c62828;
            }
            #timeline-chart {
                margin-top: 16px;
                border-top: 1px solid var(--muted);
                padding-top: 16px;
            }
            .recent-events {
                margin-top: 12px;
            }
            .recent-events h4 {
                font-size: 14px;
                margin: 0 0 8px 0;
                color: #666;
            }
            .event-list {
                display: flex;
                flex-direction: column;
                gap: 4px;
            }
            .event-entry {
                padding: 8px 10px;
                background: var(--bg);
                border-radius: 6px;
                font-size: 13px;
                display: flex;
                justify-content: space-between;
                align-items: center;
            }
            .event-type {
                font-weight: 600;
                color: var(--primary);
                text-transform: capitalize;
            }
            .event-value {
                color: #333;
                margin-left: 4px;
            }
            .event-time {
                color: #999;
                font-size: 12px;
            }
            .modal-overlay {
                display: none;
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0, 0, 0, 0.5);
                z-index: 1000;
                align-items: center;
                justify-content: center;
            }
            .modal-overlay.show {
                display: flex;
            }
            .modal {
                background: var(--card);
                padding: 20px;
                border-radius: 12px;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
                max-width: 90%;
                width: 300px;
            }
            .modal h3 {
                margin: 0 0 16px 0;
                font-size: 16px;
            }
            .modal input[type="datetime-local"] {
                width: 100%;
                padding: 10px;
                border-radius: 8px;
                border: 1px solid #ddd;
                font-size: 15px;
                box-sizing: border-box;
                margin-bottom: 16px;
            }
            .modal-buttons {
                display: flex;
                gap: 8px;
            }
            .modal-buttons button {
                flex: 1;
                padding: 10px;
                border-radius: 8px;
                border: 0;
                cursor: pointer;
                font-size: 14px;
            }
            .modal-buttons .cancel {
                background: var(--muted);
            }
            .modal-buttons .confirm {
                background: var(--primary);
                color: #fff;
            }
        </style>
        <script>
            let db = null;

            // Initialize IndexedDB
            async function initDB() {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open("BabyLogDB", 1);

                    request.onerror = () => reject(request.error);
                    request.onsuccess = () => {
                        db = request.result;
                        resolve(db);
                    };

                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        if (!db.objectStoreNames.contains("entries")) {
                            const objectStore = db.createObjectStore(
                                "entries",
                                { keyPath: "id", autoIncrement: true }
                            );
                            objectStore.createIndex("timestamp", "ts", {
                                unique: false,
                            });
                        }
                    };
                });
            }

            // Add a single entry to the database
            async function addEntry(type, value, ts) {
                if (!db) await initDB();

                const transaction = db.transaction(["entries"], "readwrite");
                const objectStore = transaction.objectStore("entries");
                const entry = { type, value, ts };
                objectStore.add(entry);

                return new Promise((resolve, reject) => {
                    transaction.oncomplete = resolve;
                    transaction.onerror = () => reject(transaction.error);
                });
            }

            // Delete the most recent entry from the database
            async function deleteMostRecentEntry() {
                if (!db) await initDB();

                const transaction = db.transaction(["entries"], "readwrite");
                const objectStore = transaction.objectStore("entries");
                const index = objectStore.index("timestamp");

                // Get all entries sorted by timestamp descending
                const request = index.openCursor(null, "prev");

                return new Promise((resolve, reject) => {
                    request.onsuccess = (event) => {
                        const cursor = event.target.result;
                        if (cursor) {
                            const deletedEntry = cursor.value;
                            cursor.delete();
                            resolve(deletedEntry);
                        } else {
                            resolve(null);
                        }
                    };
                    request.onerror = () => reject(request.error);
                });
            }

            async function loadEntriesByDate(date) {
                if (!db) await initDB();

                const transaction = db.transaction(["entries"], "readonly");
                const objectStore = transaction.objectStore("entries");
                
                let range;
                if (date) {
                    const { start, end } = getDayBounds(date);
                    // Query 12 hours before and after to catch sleep periods that cross midnight
                    const expandedStart = new Date(new Date(start).getTime() - 12 * 60 * 60 * 1000).toISOString();
                    const expandedEnd = new Date(new Date(end).getTime() + 12 * 60 * 60 * 1000).toISOString();
                    range = IDBKeyRange.bound(expandedStart, expandedEnd);
                } else {
                    const yesterday = new Date(Date.now() - 36 * 60 * 60 * 1000).toISOString();
                    range = IDBKeyRange.lowerBound(yesterday);
                }
                
                const request = objectStore.index("timestamp").getAll(range);

                return new Promise((resolve, reject) => {
                    request.onsuccess = () => resolve(request.result || []);
                    request.onerror = () => reject(request.error);
                });
            }

            async function clearAllEntries() {
                if (!db) await initDB();

                const transaction = db.transaction(["entries"], "readwrite");
                const objectStore = transaction.objectStore("entries");
                objectStore.clear();

                return new Promise((resolve, reject) => {
                    transaction.oncomplete = resolve;
                    transaction.onerror = () => reject(transaction.error);
                });
            }

            function nowIso() {
                return new Date().toISOString();
            }

            // Helper to format elapsed time
            function formatElapsedTime(timestampMs) {
                const elapsed = Math.floor((Date.now() - timestampMs) / 1000 / 60);
                const hours = Math.floor(elapsed / 60);
                const mins = elapsed % 60;
                return hours > 0 ? `${hours}h ${mins}m ago` : `${mins}m ago`;
            }

            // Helper to create day boundary timestamps
            function getDayBounds(date) {
                // Create start/end in local timezone, then convert to UTC for storage comparison
                const start = new Date(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0, 0);
                const end = new Date(date.getFullYear(), date.getMonth(), date.getDate(), 23, 59, 59, 999);
                return { start: start.toISOString(), end: end.toISOString() };
            }
            
            // Helper to get day bounds as Date objects (not ISO strings)
            function getDayBoundsAsDate(date) {
                const { start, end } = getDayBounds(date);
                return { dayStart: new Date(start), dayEnd: new Date(end) };
            }
            
            // Helper to check if an entry is within day boundaries
            function isEntryInDay(entry, dayStart, dayEnd) {
                const ts = new Date(entry.ts);
                return ts >= dayStart && ts <= dayEnd;
            }
            
            // Helper to filter entries to only those within the day
            function filterEntriesInDay(entries, date) {
                const { dayStart, dayEnd } = getDayBoundsAsDate(date);
                return entries.filter(e => isEntryInDay(e, dayStart, dayEnd));
            }

            // Helper to update button display with time and highlight
            function updateButtonDisplay(btn, label, timeStr = null, highlight = false) {
                if (!btn) return;
                const opacity = highlight ? "0.9" : "0.8";
                btn.style.background = highlight ? "var(--primary)" : "";
                btn.style.color = highlight ? "#fff" : "";
                btn.innerHTML = timeStr 
                    ? `${label}<br><small style="font-size: 11px; opacity: ${opacity};">${timeStr}</small>`
                    : label;
            }

            // Long-press detection
            let longPressTimer = null;
            let longPressData = null;

            function handleLongPressStart(type, value, btn, event) {
                event.preventDefault();
                longPressTimer = setTimeout(() => {
                    // Show time picker modal
                    longPressData = { type, value, btn };
                    showTimePicker();
                }, 500); // 500ms for long press
            }

            function handleLongPressEnd() {
                if (longPressTimer) {
                    clearTimeout(longPressTimer);
                    longPressTimer = null;
                }
            }

            function showTimePicker() {
                const modal = document.getElementById("time-picker-modal");
                const input = document.getElementById("custom-time");

                // Set default to current time in local timezone
                // datetime-local expects format: YYYY-MM-DDTHH:mm
                const now = new Date();
                const year = now.getFullYear();
                const month = String(now.getMonth() + 1).padStart(2, '0');
                const day = String(now.getDate()).padStart(2, '0');
                const hours = String(now.getHours()).padStart(2, '0');
                const minutes = String(now.getMinutes()).padStart(2, '0');
                input.value = `${year}-${month}-${day}T${hours}:${minutes}`;

                modal.classList.add("show");
            }

            function hideTimePicker() {
                const modal = document.getElementById("time-picker-modal");
                modal.classList.remove("show");
                longPressData = null;
            }

            // Helper to find last sleep start entry
            function findLastSleepStart(entries) {
                return [...entries]
                    .reverse()
                    .find(e => e.type === "sleep" && (e.value === "sleeping" || e.value === "nap"));
            }

            // Handle short sleep removal (< 5 minutes)
            async function handleShortSleep(awakeTime) {
                const allEntries = await loadEntriesByDate();
                const lastSleepStart = findLastSleepStart(allEntries);
                
                if (!lastSleepStart) return false;
                
                const sleepDuration = (awakeTime - new Date(lastSleepStart.ts)) / 1000 / 60;
                
                if (sleepDuration < 1) {
                    const transaction = db.transaction(["entries"], "readwrite");
                    const objectStore = transaction.objectStore("entries");
                    await new Promise((resolve, reject) => {
                        const deleteRequest = objectStore.delete(lastSleepStart.id);
                        deleteRequest.onsuccess = resolve;
                        deleteRequest.onerror = () => reject(deleteRequest.error);
                    });
                    return true;
                }
                return false;
            }

            async function save(type, value, btn, customTimestamp = null) {
                const ts = customTimestamp || nowIso();
                const eventTime = new Date(ts);

                // Add animation
                if (btn) {
                    btn.classList.add("fading");
                    setTimeout(() => {
                        btn.classList.remove("fading");
                    }, 400);
                }

                // Auto-awake: if recording any non-sleep event, mark baby as awake first
                if (type !== "sleep") {
                    const allEntries = await loadEntriesByDate();
                    const lastSleepEvent = [...allEntries].reverse().find(e => e.type === "sleep");
                    const isAsleep = lastSleepEvent && (lastSleepEvent.value === "sleeping" || lastSleepEvent.value === "nap");
                    
                    if (isAsleep) {
                        // Add awake event just before this event (1 second earlier to maintain order)
                        const awakeTs = new Date(eventTime.getTime() - 1000).toISOString();
                        await addEntry("sleep", "awake", awakeTs);
                    }
                }

                // Special handling for sleep awake events - remove short sleeps
                if (type === "sleep" && value === "awake") {
                    const removed = await handleShortSleep(eventTime);
                    if (removed) {
                        updateTimestamp("Short sleep removed");
                        updateDailyReport();
                        updateButtonStates();
                        return;
                    }
                }

                // Persist this single entry
                await addEntry(type, value, ts);

                updateTimestamp("Saved: " + eventTime.toLocaleTimeString());
                updateDailyReport();
                updateButtonStates();
            }

            async function saveWithCustomTime() {
                const input = document.getElementById("custom-time");
                const customTime = new Date(input.value);

                if (!customTime || isNaN(customTime.getTime())) {
                    alert("Please select a valid time");
                    return;
                }

                const { type, value, btn } = longPressData;
                await save(type, value, btn, customTime.toISOString());
                hideTimePicker();
            }

            async function undo() {
                const deletedEntry = await deleteMostRecentEntry();

                if (deletedEntry) {
                    updateTimestamp("Undone");
                    updateDailyReport();
                    updateButtonStates();
                }
            }

            function updateTimestamp(text) {
                const stamp = document.getElementById("laststamp");
                if (stamp) stamp.textContent = text;
            }

            async function saveNote(e) {
                const v = e.target.value.trim();
                if (!v) return;
                await save("note", v);
                e.target.value = "";
            }

            async function downloadCSV() {
                const entries = await loadEntriesByDate();

                if (!entries || entries.length === 0) {
                    alert("No data to export");
                    return;
                }

                const header = "Timestamp,Type,Value";
                const rows = entries.map((e) => {
                    // Convert UTC timestamp to ISO format with local timezone offset
                    const date = new Date(e.ts);
                    const offset = -date.getTimezoneOffset();
                    const sign = offset >= 0 ? '+' : '-';
                    const hours = String(Math.floor(Math.abs(offset) / 60)).padStart(2, '0');
                    const mins = String(Math.abs(offset) % 60).padStart(2, '0');
                    
                    const year = date.getFullYear();
                    const month = String(date.getMonth() + 1).padStart(2, '0');
                    const day = String(date.getDate()).padStart(2, '0');
                    const hour = String(date.getHours()).padStart(2, '0');
                    const minute = String(date.getMinutes()).padStart(2, '0');
                    const second = String(date.getSeconds()).padStart(2, '0');
                    
                    const localTime = `${year}-${month}-${day}T${hour}:${minute}:${second}${sign}${hours}:${mins}`;
                    return `"${localTime}","${e.type}","${e.value}"`;
                });
                const csv = [header, ...rows].join("\n");

                const blob = new Blob([csv], {
                    type: "text/csv;charset=utf-8;",
                });
                const url = URL.createObjectURL(blob);
                const a = document.createElement("a");
                a.href = url;
                a.download =
                    "baby_log_" +
                    new Date().toISOString().split("T")[0] +
                    ".csv";
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }

            async function updateButtonStates() {
                if (!db) await initDB();

                // Load today's entries
                const today = new Date();
                const { start, end } = getDayBounds(today);
                const transaction = db.transaction(["entries"], "readonly");
                const objectStore = transaction.objectStore("entries");
                const request = objectStore.index("timestamp").getAll(IDBKeyRange.bound(start, end));

                const allEntries = await new Promise((resolve, reject) => {
                    request.onsuccess = () => resolve(request.result || []);
                    request.onerror = () => reject(request.error);
                });

                if (!allEntries || allEntries.length === 0) return;

                // Find last feed and update button
                const lastFeed = [...allEntries].reverse().find(e => e.type === "feed" && e.value === "bf");
                const feedBtn = document.querySelector('button[data-type="feed"][data-value="bf"]');
                const feedTime = lastFeed ? formatElapsedTime(new Date(lastFeed.ts).getTime()) : null;
                updateButtonDisplay(feedBtn, "Feed", feedTime, false);

                // Find last sleep event and update sleep/awake buttons
                const lastSleepEvent = [...allEntries].reverse().find(e => e.type === "sleep");
                const sleepBtn = document.querySelector('button[data-type="sleep"][data-value="sleeping"]');
                const awakeBtn = document.querySelector('button[data-type="sleep"][data-value="awake"]');

                if (sleepBtn && awakeBtn) {
                    const isAsleep = lastSleepEvent && (lastSleepEvent.value === "sleeping" || lastSleepEvent.value === "nap");
                    const sleepTime = lastSleepEvent ? formatElapsedTime(new Date(lastSleepEvent.ts).getTime()) : null;
                    
                    if (lastSleepEvent) {
                        updateButtonDisplay(sleepBtn, "Sleeping", isAsleep ? sleepTime : null, isAsleep);
                        updateButtonDisplay(awakeBtn, "Awake", !isAsleep ? sleepTime : null, !isAsleep);
                    } else {
                        // No sleep events today - default to awake
                        updateButtonDisplay(sleepBtn, "Sleeping", null, false);
                        updateButtonDisplay(awakeBtn, "Awake", null, true);
                    }
                }
            }

            document.addEventListener("keydown", (e) => {
                if (
                    e.key === "Enter" &&
                    document.activeElement?.id === "notes"
                ) {
                    saveNote({ target: document.activeElement });
                }
            });

            // Initialize database on load
            initDB();

            // Update button states every minute to keep elapsed times current
            setInterval(() => {
                updateButtonStates();
            }, 60000); // 60000ms = 1 minute

            // Daily Report Functions
            let currentReportDate = new Date();

            function setReportDate(date) {
                currentReportDate = new Date(date);
                updateDailyReport();
            }

            function changeReportDate(days) {
                currentReportDate.setDate(currentReportDate.getDate() + days);
                document.getElementById("report-date").valueAsDate =
                    currentReportDate;
                updateDailyReport();
            }

            // Button Configuration
            const buttonGroups = [
                {
                    buttons: [
                        { type: "feed", value: "bf", label: "Feed" },
                        { type: "feed", value: "play", label: "Play" },
                    ],
                },
                {
                    buttons: [
                        { type: "sleep", value: "sleeping", label: "Sleeping" },
                        { type: "sleep", value: "nap", label: "Nap" },
                        { type: "sleep", value: "awake", label: "Awake" },
                        { type: "sleep", value: "grizzle", label: "Grizzle" },
                    ],
                },
                {
                    buttons: [
                        { type: "nappy", value: "wet", label: "Wet" },
                        { type: "nappy", value: "dirty", label: "Dirty" },
                        { type: "nappy", value: "spew", label: "Spew" },
                    ],
                },
                {
                    buttons: [
                        { type: "soothe", value: "pram", label: "Pram" },
                        { type: "soothe", value: "rocking", label: "Rocking" },
                        { type: "soothe", value: "wearing", label: "Wearing" },
                        {
                            type: "soothe",
                            value: "feed-to-sleep",
                            label: "Feed to Sleep",
                        },
                    ],
                },
                {
                    buttons: [
                        { type: "5s", value: "swaddle", label: "Swaddle" },
                        {
                            type: "5s",
                            value: "side-lying",
                            label: "Side/Stomach",
                        },
                        { type: "5s", value: "shush", label: "Shush" },
                        { type: "5s", value: "swing", label: "Swing" },
                        { type: "5s", value: "suck", label: "Suck" },
                    ],
                },
            ];

            // Generate buttons dynamically
            function renderButtons() {
                const container = document.querySelector(".container");
                const h2 = container.querySelector("h2");

                // Remove existing button cards
                const existingCards = container.querySelectorAll(
                    ".card:not(#daily-report .card)"
                );
                existingCards.forEach((card) => {
                    if (!card.querySelector("#notes")) {
                        card.remove();
                    }
                });

                // Insert button groups after the h2
                buttonGroups.reverse().forEach((group) => {
                    const card = document.createElement("div");
                    card.className = "card";

                    const row = document.createElement("div");
                    row.className = "row";

                    group.buttons.forEach((btn) => {
                        const button = document.createElement("button");
                        button.className = "action";
                        button.dataset.type = btn.type;
                        button.dataset.value = btn.value;
                        button.textContent = btn.label;
                        button.onclick = function () {
                            save(btn.type, btn.value, this);
                        };
                        button.onpointerdown = function (e) {
                            handleLongPressStart(btn.type, btn.value, this, e);
                        };
                        button.onpointerup = handleLongPressEnd;
                        button.onpointercancel = handleLongPressEnd;

                        row.appendChild(button);
                    });

                    card.appendChild(row);
                    h2.insertAdjacentElement("afterend", card);
                });
            }

            // Render buttons on load (moved to DOM ready below)

            async function updateDailyReport() {
                const allEntries = await loadEntriesByDate(currentReportDate);
                
                // Filter to only entries within the current day for display purposes
                const entriesInDay = filterEntriesInDay(allEntries, currentReportDate);

                // Calculate statistics (uses allEntries for cross-midnight sleep)
                const stats = calculateDailyStats(allEntries);
                updateStatsDisplay(stats);
                
                // Display functions use filtered entries only
                updateHourlyGrid(entriesInDay);
                updateSleepAttempts(entriesInDay);
                updateRecentEvents(entriesInDay);
                
                // Timeline needs allEntries to show cross-midnight sleep properly
                drawTimeline(allEntries);
            }

            function calculateDailyStats(entries) {
                const sleepEvents = entries.filter((e) => e.type === "sleep");
                
                // Get day boundaries for clipping sleep periods
                const { dayStart, dayEnd } = getDayBoundsAsDate(currentReportDate);
                
                // Only count feeds and nappies that occurred within the day
                const feedEvents = entries.filter((e) => {
                    return e.type === "feed" && e.value === "bf" && isEntryInDay(e, dayStart, dayEnd);
                });
                
                const wetCount = entries.filter((e) => {
                    return e.type === "nappy" && e.value === "wet" && isEntryInDay(e, dayStart, dayEnd);
                }).length;
                
                const dirtyCount = entries.filter((e) => {
                    return e.type === "nappy" && e.value === "dirty" && isEntryInDay(e, dayStart, dayEnd);
                }).length;

                let totalSleepMinutes = 0;
                let currentSleepStart = null;

                sleepEvents.forEach((event, i) => {
                    if (event.value === "sleeping" || event.value === "nap") {
                        currentSleepStart = new Date(event.ts);
                    } else if (event.value === "awake" && currentSleepStart) {
                        const awakeTime = new Date(event.ts);
                        
                        // Clip sleep period to the current day's boundaries
                        const clippedStart = currentSleepStart < dayStart ? dayStart : currentSleepStart;
                        const clippedEnd = awakeTime > dayEnd ? dayEnd : awakeTime;
                        
                        // Only count if the clipped period is within the day
                        if (clippedEnd > clippedStart) {
                            const duration = (clippedEnd - clippedStart) / 1000 / 60;
                            totalSleepMinutes += duration;
                        }
                        currentSleepStart = null;
                    }
                });
                
                // Handle ongoing sleep that hasn't ended yet
                if (currentSleepStart) {
                    const now = new Date();
                    const reportDate = currentReportDate;
                    const isToday = reportDate.toDateString() === now.toDateString();
                    
                    if (isToday) {
                        // Clip to current time if viewing today
                        const clippedStart = currentSleepStart < dayStart ? dayStart : currentSleepStart;
                        const clippedEnd = now > dayEnd ? dayEnd : now;
                        
                        if (clippedEnd > clippedStart) {
                            const duration = (clippedEnd - clippedStart) / 1000 / 60;
                            totalSleepMinutes += duration;
                        }
                    } else {
                        // For past days, assume sleep continued until end of day
                        const clippedStart = currentSleepStart < dayStart ? dayStart : currentSleepStart;
                        if (dayEnd > clippedStart) {
                            const duration = (dayEnd - clippedStart) / 1000 / 60;
                            totalSleepMinutes += duration;
                        }
                    }
                }

                const hours = Math.floor(totalSleepMinutes / 60);
                const minutes = Math.round(totalSleepMinutes % 60);

                return {
                    totalSleep: `${hours}h ${minutes}m`,
                    feedCount: feedEvents.length,
                    wetCount: wetCount,
                    dirtyCount: dirtyCount,
                };
            }

            function updateStatsDisplay(stats) {
                document.getElementById("stat-sleep").textContent =
                    stats.totalSleep;
                document.getElementById("stat-feeds").textContent =
                    stats.feedCount;
                document.getElementById("stat-wet").textContent =
                    stats.wetCount;
                document.getElementById("stat-dirty").textContent =
                    stats.dirtyCount;
            }

            function updateHourlyGrid(entries) {
                for (let hour = 0; hour < 24; hour++) {
                    const hourEntries = entries.filter((e) => {
                        const entryHour = new Date(e.ts).getHours();
                        return entryHour === hour;
                    });

                    const indicators = ["feed", "sleep", "wet", "dirty"];
                    indicators.forEach((type) => {
                        const el = document.getElementById(
                            `hour-${hour}-${type}`
                        );
                        if (el) {
                            const hasEvent = hourEntries.some((e) => {
                                if (type === "feed")
                                    return (
                                        e.type === "feed" && e.value === "bf"
                                    );
                                if (type === "sleep")
                                    return (
                                        e.type === "sleep" &&
                                        (e.value === "sleeping" ||
                                            e.value === "nap")
                                    );
                                if (type === "wet" || type === "dirty")
                                    return (
                                        e.type === "nappy" && e.value === type
                                    );
                                return e.type === type;
                            });
                            el.style.opacity = hasEvent ? "1" : "0.2";
                        }
                    });
                }
            }

            function updateSleepAttempts(entries) {
                const sleepEvents = entries.filter((e) => e.type === "sleep");
                const sootheEvents = entries.filter(
                    (e) => e.type === "soothe" || e.type === "5s"
                );

                const attempts = [];
                let currentAttempt = null;

                sleepEvents.forEach((event, i) => {
                    if (event.value === "sleeping" || event.value === "nap") {
                        if (currentAttempt) {
                            attempts.push(currentAttempt);
                        }
                        currentAttempt = {
                            start: new Date(event.ts),
                            type: event.value,
                            soothe: [],
                        };
                    } else if (event.value === "awake" && currentAttempt) {
                        currentAttempt.end = new Date(event.ts);
                        const duration =
                            (currentAttempt.end - currentAttempt.start) /
                            1000 /
                            60;
                        currentAttempt.success = duration > 15; // More than 15 minutes = success
                        attempts.push(currentAttempt);
                        currentAttempt = null;
                    }
                });

                if (currentAttempt) {
                    currentAttempt.success = true; // Still sleeping
                    attempts.push(currentAttempt);
                }

                const container = document.getElementById(
                    "sleep-attempts-list"
                );
                container.innerHTML = "";

                attempts.forEach((attempt) => {
                    const div = document.createElement("div");
                    div.className = `attempt ${
                        attempt.success ? "success" : "fail"
                    }`;

                    const timeStr = attempt.start.toLocaleTimeString([], {
                        hour: "2-digit",
                        minute: "2-digit",
                    });
                    let durationStr = "";
                    if (attempt.end) {
                        const mins = Math.round(
                            (attempt.end - attempt.start) / 1000 / 60
                        );
                        durationStr = `${mins}m`;
                    } else {
                        durationStr = "ongoing";
                    }

                    div.innerHTML = `
                        <span>${timeStr} - ${attempt.type}</span>
                        <span>${durationStr} ${
                        attempt.success ? "✓" : "✗"
                    }</span>
                    `;
                    container.appendChild(div);
                });
            }

            function updateRecentEvents(entries) {
                const container = document.getElementById("recent-events-list");
                if (!container) return;

                container.innerHTML = "";

                // Show all events for the selected day in reverse chronological order
                const allEvents = [...entries].reverse();

                allEvents.forEach((e) => {
                    const div = document.createElement("div");
                    div.className = "event-entry";

                    const time = new Date(e.ts);
                    const timeStr = time.toLocaleTimeString([], {
                        hour: "2-digit",
                        minute: "2-digit",
                    });

                    div.innerHTML = `
                        <div>
                            <span class="event-type">${e.type}</span><span class="event-value">: ${e.value}</span>
                        </div>
                        <span class="event-time">${timeStr}</span>
                    `;
                    container.appendChild(div);
                });
            }

            function drawTimeline(entries) {
                const container = document.getElementById("timeline-chart");
                container.innerHTML = "";

                const width = container.clientWidth || 600;
                const height = 200;
                const margin = { top: 20, right: 20, bottom: 30, left: 40 };

                const svg = d3
                    .select("#timeline-chart")
                    .append("svg")
                    .attr("width", width)
                    .attr("height", height);

                // Get day boundaries
                const { dayStart, dayEnd } = getDayBoundsAsDate(currentReportDate);
                
                // Filter to entries we care about for display
                const dayStart12HoursBefore = new Date(dayStart.getTime() - 12 * 60 * 60 * 1000);
                const dayEnd12HoursAfter = new Date(dayEnd.getTime() + 12 * 60 * 60 * 1000);
                
                const relevantEntries = entries.filter(e => {
                    const ts = new Date(e.ts);
                    return ts >= dayStart12HoursBefore && ts <= dayEnd12HoursAfter;
                });

                if (relevantEntries.length === 0) {
                    svg.append("text")
                        .attr("x", width / 2)
                        .attr("y", height / 2)
                        .attr("text-anchor", "middle")
                        .style("fill", "#999")
                        .text("No data for this day");
                    return;
                }

                // Prepare data for timeline - convert timestamps to hours relative to day start
                const sleepData = [];
                const feedData = [];

                relevantEntries.forEach((e) => {
                    const date = new Date(e.ts);
                    // Calculate hours relative to the start of the viewing day
                    const hours = (date - dayStart) / (1000 * 60 * 60);

                    if (e.type === "sleep") {
                        sleepData.push({ time: hours, value: e.value });
                    } else if (e.type === "feed" && e.value === "bf") {
                        // Only show feeds that are within the 0-24 range
                        if (hours >= 0 && hours < 24) {
                            feedData.push({ time: hours });
                        }
                    }
                });

                // Create scales
                const x = d3
                    .scaleLinear()
                    .domain([0, 24])
                    .range([margin.left, width - margin.right]);

                const y = d3
                    .scaleLinear()
                    .domain([0, 2])
                    .range([height - margin.bottom, margin.top]);

                // Draw gridlines for every hour
                for (let hour = 0; hour <= 24; hour++) {
                    svg.append("line")
                        .attr("x1", x(hour))
                        .attr("x2", x(hour))
                        .attr("y1", margin.top)
                        .attr("y2", height - margin.bottom)
                        .attr("stroke", "#e0e0e0")
                        .attr("stroke-width", 1)
                        .attr("opacity", 0.5);
                }

                // Draw axes with fewer ticks (every 3 hours)
                svg.append("g")
                    .attr("transform", `translate(0,${height - margin.bottom})`)
                    .call(
                        d3
                            .axisBottom(x)
                            .ticks(8)
                            .tickValues([0, 3, 6, 9, 12, 15, 18, 21, 24])
                            .tickFormat((d) => d + "h")
                    );

                // Draw sleep periods as rectangles
                let sleepStart = null;
                sleepData.forEach((d, i) => {
                    if (d.value === "sleeping" || d.value === "nap") {
                        sleepStart = d.time;
                    } else if (d.value === "awake" && sleepStart !== null) {
                        // Clip sleep period to 0-24 hour range
                        const clippedStart = Math.max(0, sleepStart);
                        const clippedEnd = Math.min(24, d.time);
                        
                        if (clippedEnd > clippedStart) {
                            svg.append("rect")
                                .attr("x", x(clippedStart))
                                .attr("y", y(1.5))
                                .attr("width", x(clippedEnd) - x(clippedStart))
                                .attr("height", 40)
                                .attr("fill", "#2196f3")
                                .attr("opacity", 0.6)
                                .attr("rx", 4);
                        }
                        sleepStart = null;
                    }
                });
                
                // Handle sleep that started before midnight (negative time values)
                if (sleepStart !== null && sleepStart < 0) {
                    // Draw from 0 to when baby woke up
                    const firstWake = sleepData.find(e => e.value === "awake" && e.time >= 0);
                    if (firstWake) {
                        const clippedEnd = Math.min(24, firstWake.time);
                        svg.append("rect")
                            .attr("x", x(0))
                            .attr("y", y(1.5))
                            .attr("width", x(clippedEnd) - x(0))
                            .attr("height", 40)
                            .attr("fill", "#2196f3")
                            .attr("opacity", 0.6)
                            .attr("rx", 4);
                    }
                    sleepStart = null;
                }
                
                // Draw ongoing sleep (if baby is still asleep)
                if (sleepStart !== null) {
                    // Get current time in hours for the selected date
                    const now = new Date();
                    const reportDate = currentReportDate;
                    const isToday = reportDate.toDateString() === now.toDateString();
                    
                    // Only show ongoing sleep if viewing today
                    if (isToday) {
                        const currentHour = now.getHours() + now.getMinutes() / 60;
                        svg.append("rect")
                            .attr("x", x(sleepStart))
                            .attr("y", y(1.5))
                            .attr("width", x(currentHour) - x(sleepStart))
                            .attr("height", 40)
                            .attr("fill", "#2196f3")
                            .attr("opacity", 0.4)
                            .attr("rx", 4)
                            .attr("stroke", "#2196f3")
                            .attr("stroke-width", 2)
                            .attr("stroke-dasharray", "5,5");
                    }
                }

                // Draw feed events as circles
                feedData.forEach((d) => {
                    svg.append("circle")
                        .attr("cx", x(d.time))
                        .attr("cy", y(0.5))
                        .attr("r", 5)
                        .attr("fill", "#4caf50");
                });

                // Add labels
                svg.append("text")
                    .attr("x", margin.left)
                    .attr("y", y(1.5) + 20)
                    .attr("text-anchor", "start")
                    .style("font-size", "12px")
                    .style("fill", "#666")
                    .text("Sleep");

                svg.append("text")
                    .attr("x", margin.left)
                    .attr("y", y(0.5) + 5)
                    .attr("text-anchor", "start")
                    .style("font-size", "12px")
                    .style("fill", "#666")
                    .text("Feed");
            }
        </script>
    </head>
    <body>
        <div class="container">
            <h2>Baby Daily Log</h2>

            <!-- Buttons will be dynamically generated here -->

            <div class="card">
                <input
                    type="text"
                    id="notes"
                    placeholder="Notes - type and press Enter"
                />
                <small id="laststamp" class="timestamp">Not yet saved</small>
            </div>

            <div style="display: flex; gap: 8px">
                <button class="btn" id="undo" onclick="undo()">Undo</button>
                <div style="flex: 1"></div>
                <button class="btn" id="download" onclick="downloadCSV()">
                    Download CSV
                </button>
            </div>

            <div id="daily-report">
                <h3>Daily Report</h3>

                <div id="date-selector">
                    <button onclick="changeReportDate(-1)">◀ Prev</button>
                    <input
                        type="date"
                        id="report-date"
                        onchange="setReportDate(this.value)"
                    />
                    <button onclick="changeReportDate(1)">Next ▶</button>
                    <button
                        onclick="setReportDate(new Date().toISOString().split('T')[0])"
                    >
                        Today
                    </button>
                </div>

                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="label">Total Sleep</div>
                        <div class="value" id="stat-sleep">0h 0m</div>
                    </div>
                    <div class="stat-card">
                        <div class="label">Feeds</div>
                        <div class="value" id="stat-feeds">0</div>
                    </div>
                    <div class="stat-card">
                        <div class="label">Wet Nappies</div>
                        <div class="value" id="stat-wet">0</div>
                    </div>
                    <div class="stat-card">
                        <div class="label">Dirty Nappies</div>
                        <div class="value" id="stat-dirty">0</div>
                    </div>
                </div>

                <h4 style="font-size: 14px; margin: 16px 0 8px 0; color: #666">
                    Hourly Activity
                </h4>
                <div class="hourly-grid" id="hourly-grid">
                    <!-- Will be populated by JS -->
                </div>

                <div id="timeline-chart"></div>

                <div class="sleep-attempts">
                    <h4>Sleep Attempts</h4>
                    <div class="attempt-list" id="sleep-attempts-list">
                        <!-- Will be populated by JS -->
                    </div>
                </div>

                <div class="recent-events">
                    <h4>Recent Events</h4>
                    <div class="event-list" id="recent-events-list">
                        <!-- Will be populated by JS -->
                    </div>
                </div>
            </div>

            <script>
                // Initialize date selector to today
                document.getElementById("report-date").valueAsDate = new Date();

                // Build hourly grid
                const hourlyGrid = document.getElementById("hourly-grid");

                // Add empty cell for top-left corner
                const corner = document.createElement("div");
                hourlyGrid.appendChild(corner);

                // Add hour labels across the top
                for (let hour = 0; hour < 24; hour++) {
                    const label = document.createElement("div");
                    label.className = "hour-label";
                    label.textContent = hour;
                    hourlyGrid.appendChild(label);
                }

                // Add rows with labels
                const rows = [
                    { label: "Feed", type: "feed" },
                    { label: "Sleep", type: "sleep" },
                    { label: "Wet", type: "wet" },
                    { label: "Dirty", type: "dirty" },
                ];

                rows.forEach((row) => {
                    // Add row label
                    const rowLabel = document.createElement("div");
                    rowLabel.className = "row-label";
                    rowLabel.textContent = row.label;
                    hourlyGrid.appendChild(rowLabel);

                    // Add indicators for each hour
                    for (let hour = 0; hour < 24; hour++) {
                        const indicator = document.createElement("div");
                        indicator.className = `hour-indicator ${row.type}`;
                        indicator.id = `hour-${hour}-${row.type}`;
                        indicator.title = `${row.label} at ${hour}:00`;
                        hourlyGrid.appendChild(indicator);
                    }
                });

                initDB().then(() => {
                    renderButtons();
                    updateDailyReport();
                    updateButtonStates();
                });

                // this function generates several days worth of test data. it is lightly random.
                async function generateTestData() {
                    const days = 7; // Generate a week of data
                    const now = new Date();

                    for (let day = days - 1; day >= 0; day--) {
                        const baseDate = new Date(now);
                        baseDate.setDate(baseDate.getDate() - day);
                        baseDate.setHours(0, 0, 0, 0);

                        // Generate sleep patterns (roughly 3-4 sleep cycles per day)
                        const sleepCycles = 3 + Math.floor(Math.random() * 2);

                        for (let cycle = 0; cycle < sleepCycles; cycle++) {
                            // Sleep start time (spread throughout 24 hours)
                            const sleepHour = Math.floor(
                                (24 / sleepCycles) * cycle + Math.random() * 2
                            );
                            const sleepMinute = Math.floor(Math.random() * 60);

                            const sleepStart = new Date(baseDate);
                            sleepStart.setHours(sleepHour, sleepMinute);

                            // Sleep type: longer sleep at night, naps during day
                            const sleepType =
                                sleepHour >= 20 || sleepHour < 6
                                    ? "sleeping"
                                    : "nap";
                            await addEntry(
                                "sleep",
                                sleepType,
                                sleepStart.toISOString()
                            );

                            // Sleep duration: 30min to 3 hours for naps, 2-5 hours for night sleep
                            let durationMinutes;
                            if (sleepType === "nap") {
                                durationMinutes = 30 + Math.random() * 150;
                            } else {
                                durationMinutes = 120 + Math.random() * 180;
                            }

                            const awakeTime = new Date(sleepStart);
                            awakeTime.setMinutes(
                                awakeTime.getMinutes() + durationMinutes
                            );

                            // Sometimes add soothe methods before sleep
                            if (Math.random() > 0.5) {
                                const sootheBefore = new Date(sleepStart);
                                sootheBefore.setMinutes(
                                    sootheBefore.getMinutes() - 5
                                );
                                const sootheMethod = [
                                    "rocking",
                                    "pram",
                                    "wearing",
                                    "feed-to-sleep",
                                ][Math.floor(Math.random() * 4)];
                                await addEntry(
                                    "soothe",
                                    sootheMethod,
                                    sootheBefore.toISOString()
                                );
                            }

                            await addEntry(
                                "sleep",
                                "awake",
                                awakeTime.toISOString()
                            );
                        }

                        // Generate feeding events (every 2-4 hours, ~6-8 feeds per day)
                        const feedCount = 6 + Math.floor(Math.random() * 3);

                        for (let feed = 0; feed < feedCount; feed++) {
                            const feedHour = Math.floor(
                                (24 / feedCount) * feed + Math.random() * 2
                            );
                            const feedMinute = Math.floor(Math.random() * 60);

                            const feedTime = new Date(baseDate);
                            feedTime.setHours(feedHour, feedMinute);

                            await addEntry(
                                "feed",
                                "bf",
                                feedTime.toISOString()
                            );

                            // Sometimes spew after feeding
                            if (Math.random() > 0.7) {
                                const spewTime = new Date(feedTime);
                                spewTime.setMinutes(
                                    spewTime.getMinutes() +
                                        10 +
                                        Math.random() * 30
                                );
                                await addEntry(
                                    "feed",
                                    "spew",
                                    spewTime.toISOString()
                                );
                            }

                            // Occasional grizzle
                            if (Math.random() > 0.8) {
                                const grizzleTime = new Date(feedTime);
                                grizzleTime.setMinutes(
                                    grizzleTime.getMinutes() -
                                        5 -
                                        Math.random() * 10
                                );
                                await addEntry(
                                    "feed",
                                    "grizzle",
                                    grizzleTime.toISOString()
                                );
                            }
                        }

                        // Generate Nappy changes (roughly 6-10 per day)
                        const NappyCount = 6 + Math.floor(Math.random() * 5);

                        for (let Nappy = 0; Nappy < NappyCount; Nappy++) {
                            const NappyHour = Math.floor(
                                (24 / NappyCount) * Nappy + Math.random() * 2
                            );
                            const NappyMinute = Math.floor(Math.random() * 60);

                            const NappyTime = new Date(baseDate);
                            NappyTime.setHours(NappyHour, NappyMinute);

                            // Most Nappies are wet
                            await addEntry(
                                "nappy",
                                "wet",
                                NappyTime.toISOString()
                            );

                            // About half are also dirty
                            if (Math.random() > 0.5) {
                                await addEntry(
                                    "nappy",
                                    "dirty",
                                    NappyTime.toISOString()
                                );
                            }
                        }

                        // Occasional use of 5 S's techniques
                        const fiveSCount = Math.floor(Math.random() * 4);
                        for (let i = 0; i < fiveSCount; i++) {
                            const fiveSHour = Math.floor(Math.random() * 24);
                            const fiveSMinute = Math.floor(Math.random() * 60);

                            const fiveSTime = new Date(baseDate);
                            fiveSTime.setHours(fiveSHour, fiveSMinute);

                            const technique = [
                                "swaddle",
                                "side-lying",
                                "shush",
                                "swing",
                                "suck",
                            ][Math.floor(Math.random() * 5)];
                            await addEntry(
                                "5s",
                                technique,
                                fiveSTime.toISOString()
                            );
                        }

                        // Add occasional notes
                        if (Math.random() > 0.6) {
                            const noteHour = Math.floor(Math.random() * 24);
                            const noteMinute = Math.floor(Math.random() * 60);

                            const noteTime = new Date(baseDate);
                            noteTime.setHours(noteHour, noteMinute);

                            const notes = [
                                "Good day!",
                                "A bit fussy today",
                                "Slept well",
                                "Cluster feeding",
                                "Very alert and happy",
                                "Seems gassy",
                                "Long stretch of sleep!",
                                "Growth spurts?",
                            ];
                            await addEntry(
                                "note",
                                notes[Math.floor(Math.random() * notes.length)],
                                noteTime.toISOString()
                            );
                        }
                    }

                    console.log(`Generated ${days} days of test data`);
                    await updateDailyReport();
                }
            </script>
        </div>

        <div
            id="time-picker-modal"
            class="modal-overlay"
            onclick="if(event.target === this) hideTimePicker()"
        >
            <div class="modal">
                <h3>Select Time</h3>
                <input type="datetime-local" id="custom-time" />
                <div class="modal-buttons">
                    <button class="cancel" onclick="hideTimePicker()">
                        Cancel
                    </button>
                    <button class="confirm" onclick="saveWithCustomTime()">
                        Save
                    </button>
                </div>
            </div>
        </div>
    </body>
</html>
