<!DOCTYPE html>
<meta charset="utf-8" />
<style>
  path {
    stroke: #fff;
  }

  /* https://stackoverflow.com/a/42613421/412529 wrap list to multiple columns */
  div#list {
    column-width: 150px;
  }
</style>

<body>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script>
    var width = 800,
      height = 800,
      padding = 10;
    radius = Math.min(width, height) / 2 - padding;

    var formatNumber = d3.format(",d");

    var angle = 0.0;
    var τ = 2 * Math.PI;
    var projections = {
      radial: {
        name: "radial",
        x: (a) => a * τ + angle, // 0..1 -> 0..τ,
        y: d3
          .scalePow() // 0..1 -> 0..r
          .exponent(1.5)
          .range([0, radius]),
        shape: d3
          .arc()
          .startAngle((d) => projections.radial.x(d.x0))
          .endAngle((d) => projections.radial.x(d.x1))
          .innerRadius((d) => Math.max(0, projections.radial.y(d.y0)))
          .outerRadius((d) => Math.max(0, projections.radial.y(d.y1))),
        translate: (d) =>
          pointRadial(projections.radial.x(d.x), projections.radial.y(d.y)),
        rotate: (d) => {
          let θ = projections.radial.x(d.x);
          return (θ * 360) / τ + (θ % τ > Math.PI ? 90 : -90);
        },
      },
    };
    var p = projections.radial;
    var currentProjection = p.name;
    var ycolor = d3
      .scaleLinear()
      .domain([0, 1])
      .range([1.5 * radius, 0.1 * radius]);

    var range100 = d3.scaleLinear().range([0, 100]);
    var root;

    var pointRadial = (θ, r) => [
      (r = +r) * Math.cos((θ -= Math.PI / 2)),
      r * Math.sin(θ),
    ];

    var cartesianToColorSpace = d3
      .scaleLinear()
      .domain([-radius, radius])
      .range([-100, 100]);
    var color = (d) => {
      var p = pointRadial((d.x * τ + 10 * angle) % τ, ycolor(d.y));
      if (d.y == 0.0) p = [0, 0]; // root grey
      return d3.lab(
        d.selected ? 50 : 70,
        cartesianToColorSpace(p[0]),
        cartesianToColorSpace(p[1])
      );
    };

    var svg = d3
      .select("body")
      .selectAll("svg")
      .attr("width", width)
      .attr("height", height)
      .append("g")
      .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")");

    function load(rows) {
      heirarchy = d3.hierarchy({ name: "root", children: rows });
      heirarchy.count();
      root = d3.partition()(heirarchy);

      for (const d of rows) {
        d.x = (d.x0 + d.x1) / 2;
        d.y = (d.y0 + d.y1) / 2;
      }
      // root node centred and not rotated
      root.x = 0.25;
      root.y = 0.0;

      update(root);
      transition(2000);
    }

    function load_text_data() {
      var raw = document.getElementById("textdata").value;
      if (!raw) return;
      const datarows = raw
        .split("\n")
        .map((t, i) => ({ RowName: t, RowIndex: i, value: 1 }));
      load(datarows);
    }

    function update(root) {
      const key = (d) => d.data.RowIndex;

      const paths = svg.selectAll("path").data(root.children, key);

      const newPaths = paths
        .enter()
        .append("path")
        .attr("d", p.shape)
        .on("click", pathclick)
        .style("fill", (d) => "white")
        .style("stroke", "#fff")
        .style("stroke-width", 1);
      newPaths.append("title").text((d) => d.data.RowName);

      paths.exit().remove();

      const texts = svg.selectAll("g").data(root.children, key);

      const newTexts = texts
        .enter()
        .append("g")
        .attr("transform", (d) => "translate(0, 0) rotate(0)")
        .on("click", pathclick);

      newTexts
        .append("text")
        .text((d) => d.data.RowName)
        .attr("text-anchor", "middle")
        .attr("dominant-baseline", "central");

      texts.exit().remove();

      texts
        .merge(newTexts)
        .selectAll("text")
        // this data() is necessary to update the child data elements that don't get recreated.
        // see https://bost.ocks.org/mike/constancy/ , or try marking some nodes then running update().
        // The panels change color (as they are parents) but the texts don't (as they are children of the g elements).
        .data((d) => [d])
        .text((d) => d.data.RowName);
    }

    function pathclick(d) {
      d.selected ^= 1;
      update_selection_display();
      transition(500);
    }

    function transition(duration, ease) {
      ease = ease || d3.easeCubic;
      var name = "tran";
      svg
        .selectAll("g") // text
        .transition(name)
        .ease(ease)
        .duration(duration)
        .attr(
          "transform",
          (d) => "translate(" + p.translate(d) + ") rotate(" + p.rotate(d) + ")"
        );

      svg
        .selectAll("text")
        .transition(name)
        .duration(duration)
        .attr("fill", (d) => (d.selected ? "white" : "black"));

      var result = svg
        .selectAll("path") // arcs
        .transition(name)
        .ease(ease)
        .duration(duration)
        .style("fill", (d) => color(d));

      if (p.name === currentProjection) result.attr("d", p.shape);
      else result.attrTween("d", pathTween(10));

      currentProjection = p.name;

      return result;
    }

    d3.select(self.frameElement).style("height", height + "px");
  </script>

  <textarea
    id="textdata"
    style="height: 1.5em; width: 20em; overflow-x: hidden; opacity: 0.5"
    placeholder="paste from spreadsheet here"
    onchange="load_text_data();"
    onkeyup="load_text_data();"
  ></textarea>

  <svg></svg>
  <div id="list">
    <ul></ul>
  </div>
</body>
