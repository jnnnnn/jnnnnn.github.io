<!DOCTYPE html>
<meta charset="utf-8" />
<style>
  path {
    stroke: #fff;
  }

  /* https://stackoverflow.com/a/42613421/412529 wrap list to multiple columns */
  div#list {
    column-width: 150px;
  }
</style>

<body>
  <svg></svg>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script>
    var width = 800,
      height = 800,
      padding = 10;
    radius = Math.min(width, height) / 2 - padding;

    var formatNumber = d3.format(",d");

    var τ = 2 * Math.PI;
    var projections = {
      radial: {
        name: "radial",
        x: (a) => a * τ, // 0..1 -> 0..τ,
        y: d3
          .scalePow() // 0..1 -> 0..r
          .exponent(1.5)
          .range([0, radius]),
        shape: d3
          .arc()
          .startAngle((d) => projections.radial.x(d.x0))
          .endAngle((d) => projections.radial.x(d.x1))
          .innerRadius((d) => Math.max(0, projections.radial.y(d.y0)))
          .outerRadius((d) => Math.max(0, projections.radial.y(d.y1))),
        translate: (d) =>
          pointRadial(projections.radial.x(d.x), projections.radial.y(d.y)),
        rotate: (d) => d.x * 360,
      },
    };
    var p = projections.radial;
    const project = (d) =>
      "translate(" + p.translate(d) + ") rotate(" + p.rotate(d) + ")";
    var ycolor = d3
      .scaleLinear()
      .domain([0, 1])
      .range([1.5 * radius, 0.1 * radius]);

    var root;

    var pointRadial = (θ, r) => [r * Math.cos(θ), r * Math.sin(θ)];

    var cartesianToColorSpace = d3
      .scaleLinear()
      .domain([-radius, radius])
      .range([-100, 100]);

    var color = (d) => {
      var p = pointRadial((d.x * τ) % τ, ycolor(d.y));
      if (d.y == 0.0) p = [0, 0]; // root grey
      return d3.lab(
        70,
        cartesianToColorSpace(p[0]),
        cartesianToColorSpace(p[1])
      );
    };

    var svg = d3
      .select("body")
      .selectAll("svg")
      .attr("width", width)
      .attr("height", height)
      .append("g")
      .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")");

    function load(rows) {
      // spread rows evenly across a height from y=0 to y=1
      heirarchy = d3.hierarchy({ name: "root", children: rows });
      heirarchy.count();
      root = d3.partition()(heirarchy);
      // compute centers of each node
      for (const d of root.children) {
        d.x = (d.x0 + d.x1) / 2;
        d.y = (d.y0 + d.y1) / 2;
      }
      // root node centred and not rotated
      root.x = 0.25;
      root.y = 0.0;

      update(root);
    }

    function load_text_data() {
      var raw = document.getElementById("textdata").value;
      if (!raw) return;
      const datarows = raw.split("\n");
      load(datarows);
    }

    function update(root) {
      const t = svg.transition().duration(750);
      console.log(root);
      const groups = svg
        .selectAll("g")
        .data(root.children)
        .join((enter) => {
          const newGroups = enter.append("g");
          const newTexts = newGroups
            .append("text")
            .attr("text-anchor", "middle")
            .attr("dominant-baseline", "central")
            .attr("fill", "black");
          const newPaths = newGroups
            .append("path")
            .style("stroke", "#fff")
            .style("stroke-width", 1);
          return newGroups;
        });

      groups.attr("transform", project);

      groups
        .selectAll("path")
        .data((d) => d)
        .attr("d", p.shape)
        .style("fill", color);

      groups
        .selectAll("text")
        .data((d) => d)
        .text((d) => d.data);
    }

    d3.select(self.frameElement).style("height", height + "px");
  </script>

  <textarea
    id="textdata"
    style="height: 20em; width: 20em; overflow-x: hidden; opacity: 0.5"
    placeholder="paste from spreadsheet here"
    onchange="load_text_data();"
    onkeyup="load_text_data();"
  ></textarea>

  <div id="list">
    <ul></ul>
  </div>
</body>
