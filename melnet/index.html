<!DOCTYPE html>
<meta charset="utf-8">
<!-- 
Melnet.html: a tool for visualising GTFS data

License: CC0
Original Author: Jonathan Newnham
-->
<style>
</style>
<title>Melnet</title>
<body>
<div id="errors"></div>
<div id="controls">
  <input type="text" id="time" size="30" />
  <button onclick="start();">Start</button>
  <button onclick="pause();">Pause</button>
  <button onclick="settime();">Set Time</button>
</div>
<div id="main">
  <svg id="chart" width="1000" height="1000">
    <!-- generated with http://open.mapquestapi.com/staticmap/v4/getmap?key=SECRET_KEY&size=1000,1000&zoom=10&center=-37.9766627535362,145.0737485429375 -->
    <image xlink:href="http://i.imgur.com/xC1rTuO.jpg" x="0" y="0" height="1000px" width="1000px" />
  </svg>
</div>
<script src="https://d3js.org/d3.v4.min.js"></script>
<script>

var width = 1000;
var height = 1000;

// 100 means fast, smooth, but requires good cpu for > 20k trips
// 1000 is much less demanding
var slowupdateinterval = 100; // ms

var stoptimesfile = "stop_times-filtered.txt"; // generate a smaller stop_times-filtered.txt using splitter.py -- big ones don't work because the browser runs out of memory loading them
var now = new Date(2017,4,1,10); // date to start from (this is 1 May 2017, 10AM) -- should match splitter.py setting
var lastnow = new Date(2000, 1, 1); // previous tick of simulation, used to know which vehicles have just appeared

// pretty terrible map alignment (cast and rectangular fit) because I can't be bothered doing a proper projection mapping.
// Background map was generated by mapquest's api with parameters zoom=10, center = 145.0737485429375,-37.9766627535362, 1000x1000px.
//  -- mapquest (like everyone else) uses the Web-Mercator projection
// Foreground coordinates (stop_lat and stop_lon) are probably in WGS-84 because that's the GTFS standard.
var lonwidth = 0.68; // manual tuning parameter
var x = d3.scaleLinear()
    .domain([145.0737485429375 - lonwidth, 145.0737485429375 + lonwidth])
    .range([0, width]);
var latwidth = 0.54; // manual tuning parameter
var y = d3.scaleLinear()
    .domain([-37.9766627535362 - latwidth, -37.9766627535362 + latwidth])
    .range([height, 0]);

var colors = d3.scaleOrdinal()
  .range(["#66aeff", "#fe7a0b", "#0bc811", "#fe5aea", "#a5a898", "#bca602", "#16bfb8", "#b59bcd", "#e98391", "#6abb81", "#93aabe", "#d1976c", "#be9ba7", "#d77efc", "#a09dfc", "#d888c3", "#89b742", "#17bae3", "#a6ac69"]);

var timer;

var datasets = [];
var parseTime = d3.timeParse("%H:%M:%S");
function parseTimeFull(s) {
  var time = parseTime(s);  
  time.setFullYear(now.getFullYear());
  time.setMonth(now.getMonth());
  time.setDate(now.getDate());
  return time;
}

function start() {
  clearInterval(timer);
  timer = setInterval(update, slowupdateinterval);

  // create a group for each dataset, to put vehicles etc. in.  
  var g = d3.select("svg").selectAll("g").data(datasets, d=>d.key);
  g.enter().append("g").attr("class", d=>"data"+d.key);
  g.exit().remove();
}

function pause() {
  clearInterval(timer);
}

function init() {
  dataset_keys = ["1","2","3","4","5","6","7","8","10","11"];
  //dataset_keys = ["2"];
  colors.domain(dataset_keys);
  for (let key of dataset_keys) {
    dataset = { 
        "key": key, 
        "gtfsdatapath": "gtfs/"+key+"/",
        "color": d3.color(colors(key)),
        "stops": [], // { "stops.txt" }
        "stops_map": d3.map(), // { stop_id : stops.txt }
        "stoptimess": [], // list of {key: trip_id, values: [stop_times.txt rows]}   sorted (by min(stop time)) 
        "stoptimessindex": 0, // performance optimization
        "vehicles": [], // { key: trip_id, lat: , lon: }
        "calendars": [], // key: service_id -> monday,tuesday,wednesday,thursday,friday,saturday,sunday,start_date,end_date
        "trips_map": d3.map(), // key: trip_id -> route_id,service_id,trip_id,shape_id,trip_headsign,direction_id

      }
    datasets.push(dataset);
    loadstops(dataset);
  }
}

function loadstops(dataset) {
  d3.select("div#errors").text("Loading stops");
  d3.csv(dataset.gtfsdatapath+"stops.txt", function(error, csv_rows) {
    if (error)
      document.getElementById("errors").innerHTML = "Couldn't load " + error.statusText;
    else {
      dataset.stops = csv_rows.map(row => ({
          stop_id: row.stop_id,
          stop_name: row.stop_name,
          stop_lat: parseFloat(row.stop_lat),
          stop_lon: parseFloat(row.stop_lon),        
      }));
      for (let stop of dataset.stops) {
        dataset.stops_map[stop.stop_id] = stop;
      }
    }
    //layout();
    renderstations();
    loadcalendar(dataset);
  });
}

function loadcalendar(dataset) {
  d3.select("div#errors").text("Loading calendar");
  d3.csv(dataset.gtfsdatapath+"calendar.txt", function(error, csv_rows) {
    if (error)
      document.getElementById("errors").innerHTML = "Couldn't load " + datafile + ": " + error.statusText;
    else {
      dataset.calendars = [];
      for (let service_row of csv_rows)
      {
        dataset.calendars.push({
          start_date: d3.timeParse("%Y%m%d")(service_row.start_date),
          end_date: d3.timeParse("%Y%m%d")(service_row.end_date),
          monday: service_row.monday,
          tuesday: service_row.tuesday,
          wednesday: service_row.wednesday,
          thursday: service_row.thursday,
          friday: service_row.friday,
          saturday: service_row.saturday,
          sunday: service_row.sunday,
          service_id: service_row.service_id,
        });
      }
    }
    loadtrips(dataset);
  });
}

function loadtrips(dataset) {
  d3.select("div#errors").text("Loading trips");
  d3.csv(dataset.gtfsdatapath+"trips.txt", function(error, csv_rows) {
    if (error)
      document.getElementById("errors").innerHTML = "Couldn't load " + datafile + ": " + error.statusText;
    else {
      for (let trip of csv_rows) {
        dataset.trips_map[trip.trip_id] = trip;
      }
    }
    loadroutes(dataset);
  });
}


function loadroutes(dataset) {
  d3.select("div#errors").text("Loading stop times");
  d3.csv(dataset.gtfsdatapath+stoptimesfile, function(error, csv_rows) {
    if (error)
      document.getElementById("errors").innerHTML = "Couldn't load " + datafile + ": " + error.statusText;
    else {
      d3.select("div#errors").text("Grouping stop times"); 
      //console.log(csv_rows[0]);    
      var allstoptimes = d3.nest()
        .key(csvrow => csvrow.trip_id)        
        .entries(csv_rows);
      //console.log(allstoptimes.length + " trips in the stop times list.");
      d3.select("div#errors").text("Parsing stop times");
      for (let stoptimes of allstoptimes) {
        for (let row of stoptimes.values) 
          row.departure_time = parseTimeFull(row.departure_time);
        stoptimes.min = d3.min(stoptimes.values.map(row=>row.departure_time));
        stoptimes.max = d3.max(stoptimes.values.map(row=>row.departure_time));
      }
      d3.select("div#errors").text("");
      //stoptimess = allstoptimes.filter(stoptimes => stoptimes.min < now && now < stoptimes.max);
      allstoptimes.sort((a,b)=>d3.ascending(a.min, b.min));
      dataset.stoptimess = allstoptimes;
    }
  });
}

var easer = function(x1, x2, t1, t2, t) {
  return  x1 + (x2 - x1) * d3.easeQuadInOut((t - t1) / (t2 - t1));
}

// I'm lazy, this is a bad algorithm -- it currently checks every trip (to see 
// if it should be displayed) every frame, and for active trips, it checks every stop. 
// A better foundation would be a queue of upcoming trips indexed by start time, and 
// each trip as a queue as well. 
// Doing that would require explicit support for discontinuous jumps though.
function computeVehiclePositions() {
  
  let day = d3.timeFormat("%A")(now).toLowerCase();
  for (let dataset of datasets) {
    let current_services = d3.set();
    for (let service of dataset.calendars)
    {    
      if (!(service[day] === "1"))
        continue;
      if (service.start_date > now)
        continue;
      if (service.end_date < now)
        continue;
      current_services.add(service.service_id);     
    }

    // remove old vehicles
    dataset.vehicles = dataset.vehicles.filter(v => v.end > now);

    // add new ones    
    let vehicles = dataset.vehicles;
    vehicles.sort((a,b)=>d3.ascending(a.key, b.key));
    for (let i = dataset.stoptimessindex; i < dataset.stoptimess.length; i++) {
      let stoptimes = dataset.stoptimess[i];

      let trip_id = stoptimes.key;
      if (!current_services.has(dataset.trips_map[trip_id].service_id))
        continue;

      if (stoptimes.min < now) {
        if (stoptimes.min >= lastnow && stoptimes.max > now) {
          // we just ticked past the min time for this trip.. so this vehicle just appeared. Add it to the active list.
          vehicles.push({ 
            key: stoptimes.key,
            start: stoptimes.min,
            end: stoptimes.max,
            legs: stoptimes.values,          
            legindex: 1, // legs[legindex] is the upcoming stop
          });
        }        
      } else {
        dataset.stoptimessindex = i; // start from this one next time, everything earlier already started (and maybe even finished)
        break; // stoptimess is sorted by min, there won't be any more starting before now
      }
    }

    // update positions
    var stops_map = dataset.stops_map;
    for (let vehicle of vehicles) {
      // iterate until we find the current leg
      for (; vehicle.legindex < vehicle.legs.length; vehicle.legindex++) {
        if (vehicle.legs[vehicle.legindex].departure_time > now) 
          break;
      }
      // compute position based on easing through the current leg
      let legstart = vehicle.legs[vehicle.legindex - 1];
      let legend = vehicle.legs[vehicle.legindex];
      vehicle.lat = easer(stops_map[legstart.stop_id].stop_lat, stops_map[legend.stop_id].stop_lat, legstart.departure_time, legend.departure_time, now);
      vehicle.lon = easer(stops_map[legstart.stop_id].stop_lon, stops_map[legend.stop_id].stop_lon, legstart.departure_time, legend.departure_time, now);
    }
  }
  lastnow = now;
}

// Computes bounds of first dataset so that it fits nicely on the screen.
function layout() {  
  let dataset = datasets[0];
  if (!(dataset.stops && dataset.stoptimess))
    return;
  var miny = d3.min(dataset.stops.map(d=>d.stop_lat));
  var maxy = d3.max(dataset.stops.map(d=>d.stop_lat));
  var minx = d3.min(dataset.stops.map(d=>d.stop_lon));
  var maxx = d3.max(dataset.stops.map(d=>d.stop_lon));
  x = d3.scaleLinear()
    .domain([minx, maxx])
    .range([0, width]);
  y = d3.scaleLinear()
    .domain([miny, maxy])
    .range([height, 0]);
}

function renderstations() {
  for (let dataset of datasets) {
    var sel = d3.select("svg")
      .select("g.data"+dataset.key)
      .selectAll("g.station").data(dataset.stops);
    sel
      .enter()
      .append("g")
        .classed("station", true)
      .append("circle")
        .style("stroke", "black")
        .style("fill", "transparent")
        .attr("cx", d=>x(d.stop_lon))
        .attr("cy", d=>y(d.stop_lat))
        .attr("r", 3)
      .append("svg:title")
        .text(d=>d.stop_name);
  }
}

function rendertracks() {
  for (let dataset of datasets) {
    var path = d3.select("svg")
      .select("g.data"+dataset.key)
      .selectAll("g.route").data(dataset.stoptimess);

    path
      .enter()
      .append("g")
        .classed("route", true)
      .append("path")
        .attr("stroke", dataset.color.darker())
        .attr("stroke-width", 1)
        .attr("fill", "transparent")
        .attr("d", d=>makepath(dataset, d.values))
      .append("title")
        .text(d=>d.key);
    path
      .exit()
      .remove();
  }
}

function renderVehicles() {
  var t = d3.transition()
      .duration(1000)
      .ease(d3.easeLinear);

  for (let dataset of datasets) {
    var vehicledots = d3.select("svg")
      .select("g.data"+dataset.key)
      .selectAll("g.vehicle")
      .data(dataset.vehicles, d=>d.key);

    vehicledots
      .enter()
      .append("g")
        .classed("vehicle", true)
        .attr("transform", d => "translate(" + x(d.lon) + "," + y(d.lat) + ")")
        .attr("opacity", 0)
      .append("circle")
        .style("stroke", dataset.color)
        .style("fill", "transparent")
        .attr("r", 1)
        
      .append("svg:title")
        .text(d=>d.key);
    
    vehicledots
      .exit()
      .remove();        
  }

  d3.select("svg").selectAll("g.vehicle")
      .attr("transform", d=>"translate(" + x(d.lon) + "," + y(d.lat) + ")")
      .transition(t)
      .attr("opacity", 1);
}

function update() {
  now = new Date(now.getTime() + 6*10*slowupdateinterval);
  d3.select("input#time").node().value = now;
  computeVehiclePositions();
  //rendertracks();
  renderVehicles();
}

function settime() {
  now = new Date(document.getElementById('time').value);
  // reset performance-optimization indices that assume time is monotonic
  for (let dataset of datasets) {
    dataset.stoptimessindex = 0;
    dataset.vehicles = [];
    /*
    for (let vehicle of dataset.vehicles)
      vehicle.legindex = 1;
    */
  }
}

// given a bunch of stop_times rows, such as
// trip_id,arrival_time,departure_time,stop_id,stop_sequence,stop_headsign,pickup_type,drop_off_type,shape_dist_traveled
// "4037.T2.2-CRB-G-mjp-1.1.H","06:21:00","06:21:00","45793","2","","0","0","8480.94045265525"
// generate an SVG path.
function makepath(dataset, csv_rows) {
  result = "M";
  for (let row of csv_rows) {
    stop = dataset.stops_map[row.stop_id];
    result += " " + Math.round(x(stop.stop_lon)) + "," + Math.round(y(stop.stop_lat));
  }
  return result;
}

init();

</script>
</body>